#include "xserver.h"

//gcc -g -fPIC -c xserver.c && gcc -g -fPIC -dynamiclib -o libxserver.dylib xserver.o -L/usr/X11/lib -lX11 -L. -lutilities -ldynamic
void *serverlist;

void *xserver_init(void *arglist)
{ 
  void *xwindow;
  void *instance;
  void *callback;
  void *guicfg;

  // ************************************ //
  // ** WRAPPER FOR XSERVER EVENT LOOP ** //
  // ************************************ //

  printf("xserver: server start up\n");
  
  //retrieve arguments, including instance tag for this window
  if(dynamic_getarg(arglist,"instance",&instance)=='f') return NULL;
  if(dynamic_getarg(arglist,"callback",&callback)=='f') return NULL;
  if(dynamic_getarg(arglist,"guiconfig",&guicfg)=='f') return NULL;

  //send instance tag to xclient for safekeeping
  arglist=NULL;
  dynamic_putarg("std.void","xclient",callback,SZ,&arglist);
  dynamic_putarg("std.char","instance",instance,SZ,&arglist);
  dynamic_call("xclient","xclient_callback_windowtag",'s',arglist,&xwindow);
  dynamic_wait(xwindow,NULL);
  dynamic_closeargs(arglist);

  #ifdef XLIB
    xserver_eventloop(callback,(char *) guicfg,(char *) instance);
  #endif
  
  printf("xserver: server shut down\n");

  return NULL; //nothing to return in the event of completion
}

void *xserver_nullwindow(void *arglist)
{
  // ******************************************* //
  // ** SET LIBRARY-GLOBAL SERVERLIST TO NULL ** //
  // ******************************************* //

  serverlist=NULL;
  return NULL;
}

#ifdef XLIB
void xserver_eventloop(void *xptr,char *guicfg,char *inst) 
{
  XEvent event;		// the XEvent declaration
  KeySym key;		// handle KeyPress Events
  char ch;
  int ctr;
  xsrv *x;
  void *arglist;
  int *running;

  // ********************************* //
  // ** RUN THE X11 EVENT WAIT LOOP ** //
  // ********************************* //

  if(invalidptr(E,xptr)) return;
  if(invalidptr(E,guicfg)) return;
  if(invalidptr(E,inst)) return;
 
  printf("xserver: beginning event loop\n");

  XInitThreads(); //allow X requests from other threads 

  x=init_x(xptr,guicfg,inst); //initialise the X data structure for this instance

  running=(int *)imalloc(E,sizeof(int));
  if(invalidptr(E,running)) return;
  *running=1;

  //look for events forever...
  ctr=0;
  while(*running) 
  {
    XNextEvent(x->dis,&event);
   
    //the following events are standard X11 window actions
    if(event.type==MapNotify)
    {
      //first thing it does
      init_features(x,ctr);
      
      //include other types of input mask hereafter
      XSelectInput(x->dis,x->win,StructureNotifyMask|ExposureMask|ButtonPressMask|KeyPressMask);
    }
    else if(event.type==Expose && event.xexpose.count==0) 
    {
      // the window was exposed redraw it! 
      init_features(x,ctr);
    }
    else if(event.type==KeyPress&&XLookupString(&event.xkey,&ch,1,&key,0)==1)  //get one-character string
    {
      request_event_keystroke(inst,ch,-1,running);
    }
    else if(event.type==ButtonPress) 
    {
      //printf("event.xbutton.button=%d\n",event.xbutton.button);
      request_event_mouse(inst,event.xbutton.x,event.xbutton.y,event.xbutton.button);
    }
    else if(event.type==ClientMessage)
    {
      if(event.xclient.data.l[0]==x->deletewindow)
        handle_shutdown_seq(x,running);
      else
        //these events are user-defined and are generated by xserver_event_send()
        xserver_event_recv(x,event.xclient.data.l,&ctr);
    }
  }

  running=ifree(E,running);
  printf("xserver: finished event loop\n");
}

void xserver_event_recv(xsrv *x,long *addr,int *ctr)
{
  long voidptr; //must be more than 32 bits
  int icmd;
  uint32_t ptr32_0,ptr32_1;
  uint64_t ptr64_0,ptr64_1;
  xreq *carg;
  func_t func;

  // ************************************************** //
  // ** GIVEN EVENT TYPE, SELECT FUNCTION TO EXECUTE ** //
  // ************************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,addr)) return;
  if(invalidptr(E,ctr)) return;

  //recover 64-bit (void *) pointer from 2 32-bit (int) values passed by XClientMessageEvent structure	
  voidptr=0x0;  //initialise to zero
  ptr32_0=(uint32_t) addr[0]; //format convert to 64-bit integer so that we have space to bit-shift
  ptr32_1=(uint32_t) addr[1];
  ptr64_0=(uint64_t) ptr32_0;
  ptr64_1=(uint64_t) ptr32_1;
  voidptr=ptr64_0|(ptr64_1<<32); //bit-shift and bit-wise OR to reconstruct 64 bit pointer
  carg=(xreq *) voidptr;

  if(!invalidptr(E,carg))
    carg->ctr=*ctr;

  //call relevant function
  for(icmd=0;icmd<x->ncmd;icmd++)
    if(carg->cmd==x->cmd[icmd])
    { 
      if(!invalidptr(E,x->func))
      {
        func=x->func[icmd];
        (*func)((void *) x,(void *) (x->wbox),(void *) carg);
      }
    }

  carg=ifree(E,carg);
  XFlush(x->dis);
  (*ctr)++;
}

void xserver_event_send(void *arg)
{
  #ifdef XLIB
    XClientMessageEvent *xevent;
    xsrv *x;
  #endif
  xreq *carg;
  void *argptr;
  uint64_t sendbit;
  
  // ******************************************************* //
  // ** PREPARE SYNTHETIC X EVENT FOR SENDING TO X SERVER ** //
  // ******************************************************* //

  #ifdef XLIB
    //typecast input request data
    carg=(xreq *) arg;
    if(invalidptr(E,carg)) return;

    //retrieve (xsrv *) structure for this window from library-global server list
    if(dynamic_getarghash(serverlist,carg->wintag,&argptr)=='f') return;
    x=(xsrv *) argptr;
    //printf("xserver: xserver_event_send X11 x=%p\n",x);
    if(invalidptr(E,x)) return;

    //allocate the event on the heap for later reference
    xevent=NULL;
    xevent=(XClientMessageEvent *)imalloc(E,sizeof(XClientMessageEvent));
    if(invalidptr(E,xevent)) return;

    memset(xevent,0,sizeof(XClientMessageEvent));

    //populate event
    xevent->type=ClientMessage;
    xevent->display=x->dis;
    xevent->window=x->win; //dbuf???
    xevent->message_type=0; //not interpreted by X11
    xevent->serial=0;
    xevent->send_event=True;
    xevent->format=32; //annoyingly, no 64-bit option
 
    //pass a 64-bit memory address (void *) pointer as 2 32-bit (int)
    sendbit=(uint64_t) carg;
    xevent->data.l[0]=(uint32_t) sendbit;         //modified from (int) to (uint32_t) with #include <stdint.h> inclusion in head_std.h
    xevent->data.l[1]=(uint32_t) (sendbit>>32);

    if(XSendEvent(x->dis,x->win,True,KeyPressMask,(XEvent *) xevent)==0) printf("xserver: error in XSendEvent()\n");
    XFlush(x->dis);
 
    xevent=ifree(E,xevent); //discard memory for xevent
  #endif
}

xsrv *init_x(void *p,char *guicfg,char *inst) 
{
  FILE *fptr;
  int nchars;
  int width;
  int height;
  char title[MAXLEN];
  unsigned long black,white;
  XWindowAttributes wa;
  xsrv *x;

  // ***************************** //
  // ** INITIALISE THE X WINDOW ** //
  // ***************************** //

  //obtain the title and size of window from configuration file
  fptr=NULL;
  if((fptr=fopen(guicfg,"r"))!=NULL)
  {
    fscanf(fptr,"title='%s\n",title);
    fscanf(fptr,"screenwidth=%d\n",&width);
    fscanf(fptr,"screenheight=%d\n",&height);
    fclose(fptr);

    printf("xserver: %s [%d %d]\n",title,width,height);
    nchars=str_length(title)-1;
    title[nchars]=STRINGEND;
  }
  else
  {
    sprintf(title,"Template");
    width=SCREENWIDTH;
    height=SCREENHEIGHT;
    nchars=str_length(title);
  }
 
  //allocate resources for X structure
  x=NULL;
  x=(xsrv *)imalloc(E,sizeof(xsrv));
  if(invalidptr(E,x)) return;

  x->dis=XOpenDisplay((char *) 0);
  x->screen=DefaultScreen(x->dis);
  black=BlackPixel(x->dis,x->screen);
  white=WhitePixel(x->dis,x->screen);
  x->root=DefaultRootWindow(x->dis);
  x->win=XCreateSimpleWindow(x->dis,x->root,0,0,width,height,5,black,white); //allocate enough internal memory for resize
  XSetStandardProperties(x->dis,x->win,title,title,None,NULL,0,NULL);
  XSelectInput(x->dis,x->win,StructureNotifyMask);
  x->vis=DefaultVisual(x->dis,0);
  x->bitdepth=DefaultDepth(x->dis,x->screen); 
  XClearWindow(x->dis,x->win);
  XMapRaised(x->dis,x->win); 
  XGetWindowAttributes(x->dis,x->win,&wa);
  x->width=wa.width;
  x->height=wa.height;
  x->depth=wa.depth;
  x->xpos=wa.x;
  x->ypos=wa.y;
  x->red_mask=wa.visual->red_mask;
  x->green_mask=wa.visual->green_mask;
  x->blue_mask=wa.visual->blue_mask;
  
  //first initialisation of double buffer and graphics contexts
  x->drgb=XCreatePixmap(x->dis,x->win,x->width,x->height,x->depth);
  x->dalpha=XCreatePixmap(x->dis,x->win,x->width,x->height,x->depth);
  x->dmask=XCreatePixmap(x->dis,x->win,x->width,x->height,1);
  x->rgbgc=XCreateGC(x->dis,x->win,0,0);   //x->win == x->drgb    
  x->alphagc=XCreateGC(x->dis,x->dalpha,0,0);        
  x->maskgc=XCreateGC(x->dis,x->dmask,0,0);        
  XSetBackground(x->dis,x->rgbgc,white);
  XSetForeground(x->dis,x->rgbgc,black);
  
  //catch close-window click event
  x->deletewindow=XInternAtom(x->dis,"WM_DELETE_WINDOW",False);
  XSetWMProtocols(x->dis,x->win,&(x->deletewindow),1);

  //work out 24 bit colour stuff
  switch(x->bitdepth) 
  {
    case 8:
      x->bquantum = 1;
    break;
    case 15:  case 16:
      x->bquantum = 2;
    break;
    case 24: case 32:
      x->bquantum = 4;
    break;
    default:
      printf("xserver: Could not determine display depth\n");
      exit(-1);
    break;
  }

  //ensure that user data can be hooked into callbacks.
  x->callback=p;

  //transfer configuration filename
  sprintf(x->guicfg,"%s",guicfg);

  //store X11 server instance in (xsrv *) for shutdown and in serverlist to disambiguate windows
  sprintf(x->instance,"%s",inst);
  dynamic_putarg("xserver.xsrv",inst,(void *) x,SZ,&serverlist);

  printf("xserver: init_x X11 x=%s %p\n",x->instance,x);
  return x;
}

void init_features(xsrv *x,int ctr)
{
  //subdivide window according to preference
  int x1,y1,x2,y2;
  FILE *fptr;
  int maxchars;
  int ic;
  char *line;
  int ibx;
  int ibpan;
  xbox *box;

  // **************************************************** //
  // ** DRAW OUT THE GUI AS DEFINED IN THE CONFIG FILE ** //
  // **************************************************** //

  if(invalidptr(E,x)) return;

  //set up command list
  init_commands(x);

  //set full window box
  init_windowbox(x);

  //set up sub-panels from gui configuration file or default
  init_panelboxes(x,x->wbox);
 
  //draw a rectangle round every panel box
  XClearWindow(x->dis,x->win);  
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,BLACK));
  for(ibx=0;ibx<x->wbox->nsboxes;ibx++)
    if(x->wbox->submem=='t'&&!invalidptr(E,x->wbox->sbox))
    {
      box=x->wbox->sbox[ibx]; 
      XDrawRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
    }
  
  //set context-dependent button arrays from gui configuration file
  ibpan=0;
  for(ibx=0;ibx<x->wbox->nsboxes;ibx++)
    if(x->wbox->submem=='t'&&!invalidptr(E,x->wbox->sbox))
      if(x->wbox->sbox[ibx]->ccontext=='b')
      {
        init_buttonboxes(x,x->wbox->sbox[ibx],ibpan);
	ibpan++;
      }

  maxchars=HISTLINE; 

  line=NULL;
  line=(char *)imalloc(E,maxchars*sizeof(char));
  
  if(!invalidptr(E,line))
  {
    fptr=fopen("history.log","wb");
    sprintf(line,"%04d",maxchars);
    for(ic=str_length(line);ic<maxchars;ic++)
      line[ic]=WHITESPACE;
    line[maxchars-1]=NEWLINE;
    fwrite(line,sizeof(char),maxchars,fptr);
    fclose(fptr);
  }

  line=ifree(E,line);
}

void init_commands(xsrv *x)
{
  int icmd;

  // ******************************** //
  // ** LIST OF ELIGIBLE COMMMANDS ** //
  // ******************************** //

  if(invalidptr(E,x)) return;

  //set up list of command functions that alter gui state
  x->ncmd=NCOMMANDS;
  x->cmd=NULL;
  x->cmd=(unsigned *)imalloc(E,x->ncmd*sizeof(unsigned));
  x->func=NULL;
  x->func=(func_t *)imalloc(E,x->ncmd*sizeof(func_t));
  icmd=0;

  if(invalidptr(E,x->cmd)) return;
  if(invalidptr(E,x->func)) return;
 
  add_command(x,"keystroke",&handle_cmd_keystroke,&icmd);
  add_command(x,"mouse",&handle_cmd_mouse,&icmd);
  add_command(x,"write",&handle_cmd_write,&icmd);
  add_command(x,"drawline",&handle_cmd_draw,&icmd);  
  add_command(x,"drawcircle",&handle_cmd_draw,&icmd);
  add_command(x,"drawsquare",&handle_cmd_draw,&icmd); 
  add_command(x,"drawpolygon",&handle_cmd_draw,&icmd);
  add_command(x,"drawraster",&handle_cmd_draw,&icmd);
  add_command(x,"layerexpose",&handle_cmd_layer,&icmd);
  add_command(x,"layerconceal",&handle_cmd_layer,&icmd);
  add_command(x,"layerinit",&handle_cmd_layer,&icmd);
  add_command(x,"layerwipe",&handle_cmd_layer,&icmd);
  add_command(x,"layerclose",&handle_cmd_layer,&icmd);
  add_command(x,"layergrab",&handle_cmd_layer,&icmd);
  add_command(x,"layertransfer",&handle_cmd_layer,&icmd);
  add_command(x,"screenclean",&handle_cmd_screen,&icmd);
  add_command(x,"screenupdate",&handle_cmd_screen,&icmd);
  add_command(x,"screengrab",&handle_cmd_screen,&icmd);
}

void add_command(xsrv *x,char *text,void (*func)(void *,void *,void *),int *icmd)
{
  // ************************************ //
  // ** EXPAND LIST OF CLIENT COMMANDS ** //
  // ************************************ //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,text)) return;
  if(invalidptr(E,icmd)) return;

  x->cmd[*icmd]=str_hash(text); 
  x->func[*icmd]=func;
  (*icmd)++;
}

void init_windowbox(xsrv *x)
{
  FILE *fptr;
  int xscreenoffset,yscreenoffset;
  int ncontexts,nbuttons,npanels;
  char ccontext;
  char fline[MAXLEN];
  char grid[MAXLEN];
  int gridnx,gridny;
  int totpanels;
  int ic,ip;
  XWindowAttributes wa;

  // ******************************************** //
  // ** SET PARAMETERS FOR UNDERLYING X WINDOW ** //
  // ******************************************** //

  if(invalidptr(E,x)) return;

  //base window initialisation (re-run after window size change)
  x->wbox=NULL;
  x->wbox=(xbox *)imalloc(E,sizeof(xbox));
  if(invalidptr(E,x->wbox)) return;

  XGetWindowAttributes(x->dis,x->win,&wa);
  x->width=wa.width;
  x->height=wa.height;
  x->depth=wa.depth;
  x->xpos=wa.x;
  x->ypos=wa.y;
  x->red_mask=wa.visual->red_mask;
  x->green_mask=wa.visual->green_mask;
  x->blue_mask=wa.visual->blue_mask;

  //ifree first initialisation to account for potential re-sizing of window
  XFreePixmap(x->dis,x->drgb);
  XFreePixmap(x->dis,x->dalpha);
  XFreePixmap(x->dis,x->dmask);

  x->drgb=XCreatePixmap(x->dis,x->win,x->width,x->height,x->depth);
  x->dalpha=XCreatePixmap(x->dis,x->win,x->width,x->height,x->depth);
  x->dmask=XCreatePixmap(x->dis,x->win,x->width,x->height,1);

  x->wbox->xmin=x->xpos;
  x->wbox->xmax=x->xpos+x->width-1;
  x->wbox->ymin=x->ypos;
  x->wbox->ymax=x->ypos+x->height-1;

  x->wbox->ctr=0;      //number of mouse-clicks (re)set to 0
  x->wbox->active='f';
  x->wbox->wrtmem='f';
  x->wbox->lyrmem='f';
  x->wbox->submem='f';

  if((fptr=fopen(x->guicfg,"r"))!=NULL)
  {
    fgets(fline,MAXLEN,fptr); //title
    fgets(fline,MAXLEN,fptr); //width
    fgets(fline,MAXLEN,fptr); //height
    fscanf(fptr,"x_screen_offset=%d\n",&xscreenoffset);
    fscanf(fptr,"y_screen_offset=%d\n",&yscreenoffset);
    fgets(fline,MAXLEN,fptr); //xfontsize
    fgets(fline,MAXLEN,fptr); //yfontsize
    fscanf(fptr,"ncontexts=%d\n",&ncontexts);
   
    totpanels=0;
    for(ic=0;ic<ncontexts;ic++)
    {
      fscanf(fptr,"context %c: nbuttons=%d npanels=%d\n",&ccontext,&nbuttons,&npanels);
      for(ip=0;ip<npanels;ip++)
      {
        gridnx=0;
        gridny=0;
        fscanf(fptr,"%s %s %s %s %s\n",fline,fline,fline,fline,grid);
        sscanf(grid,"grid=%d,%d",&gridnx,&gridny);
        if(ccontext=='i') totpanels+=gridnx*gridny;  //corruption of hierarchy so images are top-level
	else              totpanels++;
        //printf("ic=%d ip=%d totpanels=%d\n",ic,ip,totpanels);
      }
    }
    
    fclose(fptr);
  }
  else
  {
    xscreenoffset=XSCREENOFFSET;
    yscreenoffset=YSCREENOFFSET;
    totpanels=NPANELS*NCONTEXTS;
  }

  //apply screen offset
  x->wbox->xmin-=xscreenoffset;
  x->wbox->xmax-=xscreenoffset;
  x->wbox->ymin-=yscreenoffset;
  x->wbox->ymax-=yscreenoffset;

  //store size of sub-box array
  x->wbox->nsboxes=totpanels;
  //printf("x->wbox->nsboxes=%d\n",x->wbox->nsboxes);
}

void init_panelboxes(xsrv *x,xbox *wbox)
{
  xbox *box;
  FILE *fptr;
  int xfontsize,yfontsize;
  char ccontext;
  int nbuttons;
  int ncontexts;
  int npanels;
  int ic,ip,ibx;
  int ix,iy,gridnx,gridny;
 
  char fline[MAXLEN];
  char xmin[MAXLEN];
  char xmax[MAXLEN];
  char ymin[MAXLEN];
  char ymax[MAXLEN];
  char grid[MAXLEN];
  char plus;
  float prop,font;
  int xmn,xmx,ymn,ymx;

  void *arglist;
  void *callback;

  // ****************************************************** //
  // ** INITIALISE THE SUB-BOXES THAT CONSTITUTE THE GUI ** //
  // ****************************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,wbox)) return;
 
  //allocate memory to sub-boxes
  //printf("x->wbox->nsboxes=%d\n",x->wbox->nsboxes);
  wbox->sbox=NULL;
  wbox->sbox=(xbox **)imalloc(E,wbox->nsboxes*sizeof(xbox *));
  for(ip=0;ip<wbox->nsboxes;ip++)
  {
    wbox->sbox[ip]=NULL;
    wbox->sbox[ip]=(xbox *)imalloc(E,sizeof(xbox));
  }
  wbox->submem='t';
  
  if((fptr=fopen(x->guicfg,"r"))!=NULL)
  {
    fgets(fline,MAXLEN,fptr); //title
    fgets(fline,MAXLEN,fptr); //width
    fgets(fline,MAXLEN,fptr); //height
    fgets(fline,MAXLEN,fptr); //xoffset
    fgets(fline,MAXLEN,fptr); //yoffset
    fscanf(fptr,"x_font_size=%d\n",&xfontsize);
    fscanf(fptr,"y_font_size=%d\n",&yfontsize);
    fscanf(fptr,"ncontexts=%d\n",&ncontexts);

    ibx=0;
    for(ic=0;ic<ncontexts;ic++)
    {
      fscanf(fptr,"context %c: nbuttons=%d npanels=%d\n",&ccontext,&nbuttons,&npanels);
      
      for(ip=0;ip<npanels;ip++)
      {
        fscanf(fptr,"%s %s %s %s %s\n",xmin,xmax,ymin,ymax,grid);
  
        sscanf(xmin,"xmin=%fx%c%fc",&prop,&plus,&font);
	if(plus=='-')
	  font*=-1.0;
        xmn=(int) (wbox->xmin+prop*(wbox->xmax-wbox->xmin)+font*xfontsize);
            
	sscanf(xmax,"xmax=%fx%c%fc",&prop,&plus,&font);
	if(plus=='-')     
	  font*=-1.0;
        xmx=(int) (wbox->xmin+prop*(wbox->xmax-wbox->xmin)+font*xfontsize);
	
	sscanf(ymin,"ymin=%fy%c%fc",&prop,&plus,&font);
	if(plus=='-')     
	  font*=-1.0;
        ymn=(int) (wbox->ymin+prop*(wbox->ymax-wbox->ymin)+font*yfontsize);
	
	sscanf(ymax,"ymax=%fy%c%fc",&prop,&plus,&font);
	if(plus=='-')     
	  font*=-1.0;
        ymx=(int) (wbox->ymin+prop*(wbox->ymax-wbox->ymin)+font*yfontsize);
        
        sscanf(grid,"grid=%d,%d",&gridnx,&gridny);
 
	if(wbox->submem=='t'&&!invalidptr(E,wbox->sbox))
	  if(!invalidptr(E,wbox->sbox[ibx]))
	  {
	    //slight corruption of the sub-box hierarchy: images should always be on top level
            if(ccontext!='i')
	    {
              gridnx=1;
	      gridny=1;
	    } 

            for(iy=0;iy<gridny;iy++)
	      for(ix=0;ix<gridnx;ix++)
              {
                box=wbox->sbox[ibx]; //put boxes into newly allocated memory
            
	        box->ccontext=ccontext;
	        box->ipanel=ip+ix+iy*gridnx; //corrupt hierarchy
                //printf("debug: box->ipanel=%d ip=%d ix=%d iy=%d\n",box->ipanel,ip,ix,iy);

		prop=((float) ix)/gridnx;
	        box->xmin=(int) (xmn+prop*(xmx-xmn));
		prop=((float) (ix+1))/gridnx;
	        box->xmax=(int) (xmn+prop*(xmx-xmn));
		prop=((float) iy)/gridny;
	        box->ymin=(int) (ymn+prop*(ymx-ymn));
		prop=((float) (iy+1))/gridny;
	        box->ymax=(int) (ymn+prop*(ymx-ymn));
		
                box->ctr=0;      //number of mouse-clicks (re)set to 0
                box->active='f';
                box->wrtmem='f';
                box->lyrmem='f';
                box->submem='f';

		box->xfontsize=xfontsize;
                box->yfontsize=yfontsize;
                reset_cursor(x,box); //initialise cursor position
     
                printf("xserver: ibx %d %c [%d:%d,%d:%d]\n",ibx,ccontext,box->xmin,box->xmax,box->ymin,box->ymax);
                
		arglist=NULL;
		dynamic_putarg("std.void","xclient",x->callback,SZ,&arglist); //size of x->callback data structure is not known by xserver
		dynamic_putarg("std.int","ipanel",(void *) &box->ipanel,SZ,&arglist);
		dynamic_putarg("std.int","npanels",(void *) &wbox->nsboxes,SZ,&arglist);
		dynamic_putarg("std.char","ccontext",(void *) &ccontext,SZ,&arglist);
		dynamic_putarg("std.int","xmn",(void *) &box->xmin,SZ,&arglist);
		dynamic_putarg("std.int","xmx",(void *) &box->xmax,SZ,&arglist);
		dynamic_putarg("std.int","ymn",(void *) &box->ymin,SZ,&arglist);
		dynamic_putarg("std.int","ymx",(void *) &box->ymax,SZ,&arglist);
		dynamic_call("xclient","xclient_callback_buffer",'s',arglist,&callback);
		dynamic_wait(callback,NULL);
		dynamic_closeargs(arglist);
	        //callback_xserver_buffer(x->callback,box->ipanel,wbox->nsboxes,ccontext,box->xmin,box->xmax,box->ymin,box->ymax);
                //void callback_xserver_buffer(void *p,int ipanel,int npanels,char ccontext,int xmn,int xmx,int ymn,int ymx)
	
	        ibx++;
	      }
          }
      }
    }
    fclose(fptr); 
  }
  else
  {
    xfontsize=XFONTSIZE;
    yfontsize=YFONTSIZE;
    ncontexts=NCONTEXTS;
    npanels=NPANELS;
  
    ibx=0;
    for(ic=0;ic<ncontexts;ic++)
      for(ip=0;ip<npanels;ip++)
      {
        box=x->wbox->sbox[ibx]; //put boxes into newly allocated memory
    
        box->xmin=wbox->xmin;
        box->xmax=wbox->xmax;
        box->ymin=wbox->ymin;
        box->ymax=wbox->ymax;
        box->xfontsize=xfontsize;
        box->yfontsize=yfontsize;
        reset_cursor(x,box); //initialise cursor position
	box->ipanel=ip;

        box->ctr=0;      //number of mouse-clicks (re)set to 0
        box->active='f';
        box->wrtmem='f';
        box->lyrmem='f';
        box->submem='f';
        
	if(ic==0)
        {
	  //image box
	  box->ccontext='i';
          box->xmax=box->xmin+0.75*(box->xmax-box->xmin);
          box->ymax=box->ymin+0.75*(box->ymax-box->ymin);
        }

        if(ic==1)
        {
	  //history box
	  box->ccontext='h';  
          box->xmin=box->xmin+0.75*(box->xmax-box->xmin);
        }

        if(ic==2)
        {
	  //command box
	  box->ccontext='c';
          box->xmax=box->xmin+0.75*(box->xmax-box->xmin);
          box->ymin=box->ymin+0.75*(box->ymax-box->ymin)+2*yfontsize;
        }

        if(ic==3)
        {
	  //button box
	  box->ccontext='b';
          box->xmax=box->xmin+0.75*(box->xmax-box->xmin);
          box->ymin=box->ymin+0.75*(box->ymax-box->ymin);
          box->ymax=box->ymin+2*yfontsize;
        }
	
	ibx++;
      }
  }
}

void init_buttonboxes(xsrv *x,xbox *box,int ibuttonpanel)
{
  FILE *fptr;
  char fline[MAXLEN];
  int totbuttons;
  int buttonspace;
  int icontext;
  int ncontexts;
  char *ctxtmap;
  int *nbuttons;
  int npanels;
  int ibutton;
  char ccontext;
  int ic,ib,ip;
  int ix,iy;
  int ibx;
  int ichar;
  char xmin[MAXLEN];
  char xmax[MAXLEN];
  char ymin[MAXLEN];
  char ymax[MAXLEN];
  char grid[MAXLEN];
  int gridnx,gridny;
  xbox *sbox;

  // ****************************************** //
  // ** INITIALISE CONTEXT-DEPENDENT BUTTONS ** //
  // ****************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(box->submem!='f') return;

  gridnx=1;
  gridny=1;

  if((fptr=fopen(x->guicfg,"r"))!=NULL)
  {
    fgets(fline,MAXLEN,fptr); //title
    fgets(fline,MAXLEN,fptr); //width
    fgets(fline,MAXLEN,fptr); //height
    fgets(fline,MAXLEN,fptr); //xscreen offset
    fgets(fline,MAXLEN,fptr); //yscreen offset
    fgets(fline,MAXLEN,fptr); //xfontsize
    fgets(fline,MAXLEN,fptr); //yfontsize
    fscanf(fptr,"ncontexts=%d\n",&ncontexts);

    //get name of context and number of buttons in each
    ctxtmap=NULL;
    nbuttons=NULL;
    ctxtmap=(char *)imalloc(E,ncontexts*sizeof(char));
    nbuttons=(int *)imalloc(E,ncontexts*sizeof(int));

    if(!invalidptr(E,ctxtmap)&&
       !invalidptr(E,nbuttons))
    {
      totbuttons=0;
      buttonspace=0;
      for(ic=0;ic<ncontexts;ic++)
      {
        fscanf(fptr,"context %c: nbuttons=%d npanels=%d\n",&(ctxtmap[ic]),&(nbuttons[ic]),&npanels);
        printf("xserver: context %c: nbuttons=%d npanels=%d\n",ctxtmap[ic],nbuttons[ic],npanels);
      
        for(ip=0;ip<npanels;ip++)
	{
	  fgets(fline,MAXLEN,fptr);

	  if(ibuttonpanel==ip&&ctxtmap[ic]=='b')     //only count space associated with this button panel
	  {
	    memset(grid,0,MAXLEN*sizeof(char));
	    sscanf(fline,"%s %s %s %s %s\n",xmin,xmax,ymin,ymax,grid);
	    sscanf(grid,"grid=%d,%d",&gridnx,&gridny);
	    buttonspace+=gridnx*gridny;
	  }
        }

        if(nbuttons[ic]>0)     //account for -1 flag in context 'b'
	  totbuttons+=nbuttons[ic];
      }
    }

    //allocate sub-boxes for each *potential* button there could be
    box->sbox=NULL;
    box->sbox=(xbox **)imalloc(E,buttonspace*sizeof(xbox *));

    if(!invalidptr(E,box->sbox)&&
       !invalidptr(E,ctxtmap)&&
       !invalidptr(E,nbuttons))
    {
      ibx=0;
      for(ib=0;ib<totbuttons;ib++)
        if(!feof(fptr))
        {
          //read button definitions
          memset(fline,0,sizeof(char)*MAXLEN);
          fscanf(fptr,"button_%d%c%d=%s\n",&ip,&ccontext,&ibutton,fline);
         
          if(!invalidptr(E,box->sbox)&&ip==ibuttonpanel) //only read buttons associated with this panel
	  {
	    if(box->submem=='f') //allocate memory for the buttons that actually appear in configuration file
            {
	      box->sbox[ibx]=NULL;
	      box->sbox[ibx]=(xbox *)imalloc(E,sizeof(xbox));
	    }

            sbox=box->sbox[ibx]; 

	    if(!invalidptr(E,sbox))
	    {
	      sbox->wrtmem='f';
	      sbox->submem='f';
	      sbox->ibutton=ibutton;
	      sbox->ipanel=ip;
	      sbox->ccontext=ccontext;
	      sbox->xfontsize=box->xfontsize;
	      sbox->yfontsize=box->yfontsize;

	      //work out context in order to find nbuttons[icontext]
	      icontext=-1;
              for(ic=0;ic<ncontexts;ic++)
	        if(sbox->ccontext==ctxtmap[ic])
	          icontext=ic;

	      //if within memory range
              if(icontext>=0&&icontext<ncontexts)
	        if(ibutton>=0&&ibutton<gridnx*gridny)
	        {
		  //set dimensions of sub-box according to 1D grid index: ibutton
		  ix=ibutton%gridnx;
                  iy=ibutton/gridnx;
		  //printf("ibutton=%d ix=%d iy=%d gridnx=%d gridny=%d\n",ibutton,ix,iy,gridnx,gridny);
                  sbox->xmin=(int) (box->xmin+((float) ix/gridnx)*(box->xmax-box->xmin));
                  sbox->xmax=(int) (box->xmin+((float) (ix+1)/gridnx)*(box->xmax-box->xmin));
                  sbox->ymin=(int) (box->ymin+((float) iy/gridny)*(box->ymax-box->ymin));
                  sbox->ymax=(int) (box->ymin+((float) (iy+1)/gridny)*(box->ymax-box->ymin));

                  //copy text from line buffer to sub-box but strip out 'quotes'
	          init_text(x,sbox);

                  if(sbox->wrtmem=='t')
                    if(!invalidptr(E,sbox->write))
                      if(!invalidptr(E,sbox->write[0]))
                      {
                        if(!invalidptr(E,sbox->write[0]->text)&&
			   !invalidptr(E,fline))
                          for(ichar=0;ichar<str_length(fline)-2;ichar++)
                            sbox->write[0]->text[ichar]=fline[ichar+1];

                        sbox->write[0]->nchars=str_length(fline)-2;
                      }

	          ibx++; //only increment box counter if we get all the way
                }
            }
	  }
	}
      box->nsboxes=ibx; //when ifreeing memory, this will only count boxes *actually* allocated; pointer array is longer but will be freed as one.
      box->submem='t';
    }

    ctxtmap=ifree(E,ctxtmap);
    nbuttons=ifree(E,nbuttons);
    fclose(fptr);

    //printf("debug: leaving buttonboxes\n");
  }
  else
  {
    if(box->submem=='f')
    {
      //allocate sub-boxes for each button
      box->nsboxes=NCONTEXTS*NBUTTONS;
      box->sbox=NULL;
      box->sbox=(xbox **)imalloc(E,box->nsboxes*sizeof(xbox *));  
      if(!invalidptr(E,box->sbox))
      {
        for(ib=0;ib<box->nsboxes;ib++)
	{
	  box->sbox[ib]=NULL;
          box->sbox[ib]=(xbox *)imalloc(E,sizeof(xbox));
        }

        for(ic=0;ic<NCONTEXTS;ic++)
          for(ib=0;ib<NBUTTONS;ib++)
          {
            if(ic==0) ccontext='i';
	    if(ic==1) ccontext='h';
	    if(ic==2) ccontext='c';
            
	    //generic button name
	    sprintf(fline,"button_0%c%d",ccontext,ib);
	  
	    ibx=ib+NBUTTONS*ic;
	    if(!invalidptr(E,box->sbox[ibx]))
	    {
              sbox=box->sbox[ibx];
          
              //set dimensions of sub-box
              sbox->ymin=box->ymin;
              sbox->ymax=box->ymax;
              sbox->xmin=box->xmin+ib*(box->xmax-box->xmin)/NBUTTONS;
              sbox->xmax=box->xmin+(ib+1)*(box->xmax-box->xmin)/NBUTTONS; 

	      sbox->ibutton=ib;
	      sbox->ccontext=ccontext;
	      sbox->wrtmem='f';
	      sbox->xfontsize=box->xfontsize;
	      sbox->yfontsize=box->yfontsize;

              //copy text from buffer to box
              init_text(x,sbox);
              
              if(sbox->wrtmem=='t')
                if(!invalidptr(E,sbox->write))
                  if(!invalidptr(E,sbox->write[0]))
                  {
                    if(!invalidptr(E,sbox->write[0]->text)&&
		       !invalidptr(E,fline))
                      for(ichar=0;ichar<str_length(fline)-2;ichar++)
                        sbox->write[0]->text[ichar]=fline[ichar+1];

                    sbox->write[0]->nchars=str_length(fline)-2;
                  }
            }
	  }
        box->submem='t';
      }
    }
  }
}

void close_subboxes(xsrv *x,xbox *box)
{
  int ib;
  xbox *sbox;

  // ********************************** //
  // ** RELEASE MEMORY FOR SUB-BOXES ** //
  // ********************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  printf("xserver: closing box %p with %d subboxes, submem=%c\n",box,box->nsboxes,box->submem);

  if(box->submem=='t')
    for(ib=0;ib<box->nsboxes;ib++)
      if(box->submem=='t'&&!invalidptr(E,box->sbox))
        if(!invalidptr(E,box->sbox[ib]))
        {
          sbox=box->sbox[ib];

          printf("xserver: sbox->submem=%c\n",sbox->submem);
         /* 
	  if(sbox->submem=='t')
	  {
	    printf("xserver: recursion\n");
	    close_subboxes(x,sbox);
	  }
	  */
	  if(sbox->wrtmem=='t')
	    close_text(x,sbox);

	  if(sbox->lyrmem=='t')
	    close_canvas(x,sbox,0);
	    
	  //recursive freeing of memory from sub-boxes
	  if(sbox->submem=='t')
	  {  
	    printf("xserver: recursion\n");
	    close_subboxes(x,sbox);
	    sbox=ifree(E,sbox);  //free each xbox individually
	  }
        }

  box->sbox=ifree(E,box->sbox); //free the list of pointers to xboxes
  box->submem='f';
}

void close_x(xsrv *x) 
{
  // ********************************************** //
  // ** RELEASE RESOURCES FOR TOP-LEVEL X WINDOW ** //
  // ********************************************** //

  if(invalidptr(E,x)) return;

  printf("xserver: closing X11\n");

  //ifree remaining x stuff for this window
  XFreeGC(x->dis,x->rgbgc);
  XFreeGC(x->dis,x->alphagc);
  XFreeGC(x->dis,x->maskgc);
  XFreePixmap(x->dis,x->drgb);
  XFreePixmap(x->dis,x->dalpha);
  XFreePixmap(x->dis,x->dmask);
  XDestroyWindow(x->dis,x->win);
  
  //keep X server connection after closure of one window
  //comment out XCloseDisplay(x->dis); 150912
}

xlyr *get_layer(xsrv *x,xbox *box,unsigned lyrhash,char *lyrname)
{
  int ilyr;
  xlyr *lyr;

  // ************************************** //
  // ** RETRIEVE LAYER BY STRING OR HASH ** //
  // ************************************** //
 
  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  //lyrname can be NULL

  lyr=NULL;
  if(!invalidptr(S,lyrname)&&lyrhash==0)
    lyrhash=str_hash(lyrname);

  if(!invalidptr(E,box))
    if(!invalidptr(E,box->layer))
      for(ilyr=0;ilyr<box->nlayers;ilyr++)
        if(!invalidptr(E,box->layer[ilyr]))
          if(box->layer[ilyr]->hash==lyrhash) 
	    lyr=box->layer[ilyr]; 

  return lyr;
}

unsigned long get_palette_grey(xsrv *x,double shade) 
{
  XColor tmp;
  char colname[MAXLEN];
  int bit;

  // ************************************************ //
  // ** GET GREY FROM PREDEFINED LIST OF X COLOURS ** //
  // ************************************************ //

  if(invalidptr(E,x)) return;

  bit=(int)(shade*100);
  sprintf(colname,"Gray%d",bit%100); //don't allow to saturate
  XParseColor(x->dis,DefaultColormap(x->dis,x->screen),colname, &tmp);
  XAllocColor(x->dis,DefaultColormap(x->dis,x->screen),&tmp);
	
  return tmp.pixel;
}

unsigned long get_palette_rgb(xsrv *x,uint8_t red,uint8_t green,uint8_t blue)
{
  //colour received in range 0<component<1

  XColor tmp;

  // ***************************************************** //
  // ** GET RGB VALUE FROM PREDEFINED LIST OF X COLOURS ** //
  // ***************************************************** //

  if(invalidptr(E,x)) return;

  tmp.red=10000+(int)(((double) red/CHWHITE)*(65535-10000));
  tmp.green=10000+(int)(((double) green/CHWHITE)*(65535-10000));
  tmp.blue=10000+(int)(((double) blue/CHWHITE)*(65535-10000));
  tmp.flags = DoRed | DoGreen | DoBlue;
  XAllocColor(x->dis,DefaultColormap(x->dis,x->screen),&tmp);

  return tmp.pixel;
}

unsigned int get_raster_rgb(xsrv *x,XImage *image,uint8_t red,uint8_t green,uint8_t blue)
{
  // ********************************************* //
  // ** CONVERT 24-BIT TRUECOLOUR TO RGB VALUES ** //
  // ********************************************* //

  if(invalidptr(E,x)) return;

  return (unsigned int) (((double) red/CHWHITE)*image->red_mask+
                         ((double) green/CHWHITE)*image->green_mask+
			 ((double) blue/CHWHITE)*image->blue_mask);
}
     
void put_raster_rgb(xsrv *x,XImage *image,unsigned int val,uint8_t *red,uint8_t *green,uint8_t *blue)
{
  // ********************************************* //
  // ** CONVERT RGB VALUES TO 16-BIT TRUECOLOUR ** //
  // ********************************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,image)) return;

  *red=(val & image->red_mask) >> 16;
  *green=(val & image->green_mask) >> 8;
  *blue=(val & image->blue_mask);
}

char mouse_in_box(xsrv *x,xbox *box,int xmouse,int ymouse)
{
  double tx;
  double ty;

  // ************************************ //
  // ** DECIDE IF MOUSE IS IN THIS BOX ** //
  // ************************************ //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  if(!invalidptr(E,box))
  {
    tx=(double) (xmouse-box->xmin)/(box->xmax-box->xmin);
    ty=(double) (ymouse-box->ymin)/(box->ymax-box->ymin);

    //printf("box->xmin=%d box->ymin=%d box->xmax=%d box->ymax=%d xmouse=%d ymouse=%d tx=%f ty=%f\n",
    //        box->xmin,box->ymin,box->xmax,box->ymax,xmouse,ymouse,tx,ty);

    if(tx>0&&tx<1&&ty>0&ty<1) return 't';
    else                      return 'f';
  }
  else
  {
    return 'f';
  }
}

void handle_cmd_keystroke(void *arg1,void *arg2,void *arg3)
{
  int ibx;
  xbox *box;
  xbox *hbox;
  char text[MAXLEN];
  char ch;
  int panel;
  int *running;

  xsrv *x;
  xbox *wbox;
  xreq *carg;
  
  // ************************************************ //
  // ** RESPOND APPROPRIATELY TO A KEYSTROKE EVENT ** //
  // ************************************************ //

  if(invalidptr(E,arg1)) return;
  if(invalidptr(E,arg2)) return;
  if(invalidptr(E,arg3)) return;

  x=(xsrv *) arg1;
  wbox=(xbox *) arg2;
  carg=(xreq *) arg3;

  ch=carg->keystroke;
  panel=carg->panel; //not currently used
  running=carg->running;
  //printf("%c\n",ch);

  box=NULL;
  hbox=NULL;
  box=handle_current_panel(x,wbox);
  hbox=handle_find_panel(x,wbox,'h',0);

  if(!invalidptr(S,box)&&
     !invalidptr(S,hbox))
  {
    if(box->ccontext=='i')
    {
      //manipulate image: zoom, move, swap layers
      handle_image_key(x,box,hbox,ch);
    }
    else if(box->ccontext=='c')
    {
      //command prompt text input
      handle_text_command(x,box,hbox,ch);
    } 
    else
    {
      //if active box is an hbox, bbox or nothing at all, then refresh or quit
      if(ch=='r') 
      {
        printf("xserver: re-initialise window\n");

        //close any previous image or text memory and start with a clean screen
	for(ibx=0;ibx<wbox->nsboxes;ibx++)
	  if(wbox->submem=='t'&&!invalidptr(E,wbox->sbox))
	    redraw_box(x,wbox->sbox[ibx]);
        
	//refresh screen 
        init_features(x,carg->ctr);

	//redraw any images at new resolution
	for(ibx=0;ibx<wbox->nsboxes;ibx++)
	  if(wbox->submem=='t'&&!invalidptr(E,wbox->sbox))
	    if(!invalidptr(E,wbox->sbox[ibx]))
	      if(wbox->sbox[ibx]->ccontext=='i')
	      {
	        box=wbox->sbox[ibx];

		handle_image_key(x,box,hbox,'r'); //'r'=reset
              }
      }
      else if(ch=='q') 
      {
        handle_shutdown_seq(x,running);
      }
    }
  }
  else
  {
    printf("xserver: invalid box, no action taken\n");
  }
}

void handle_shutdown_seq(xsrv *x,int *running)
{
  void *callback;
  void *arglist;
  char instance[MAXLEN];

  // *********************************************** //
  // ** RESPOND TO WINDOW CLOSURE OR QUIT COMMAND ** //
  // *********************************************** //

  if(invalidptr(E,x)) return;

  //copy out string name of this window instance
  sprintf(instance,"%s",x->instance);

  //close child threads of the gui before releasing gui resources
  dynamic_call("xclient","xclient_callback_shutdown",'s',NULL,&callback);
  dynamic_wait(callback,NULL);
 
  //release resources for this window
  close_subboxes(x,x->wbox);
  close_x(x);

  //delete this window from X server list
  dynamic_delarg(serverlist,instance,'d');

  *running=0;
}

void handle_image_key(xsrv *x,xbox *box,xbox *hbox,char ch)
{
  void *callback;
  void *arglist;
  int scrnx;
  int scrny;

  // *************************************************************** //
  // ** RESPOND TO A REDRAW REQUEST BY ASKING CLIENT WHAT TO DRAW ** //
  // *************************************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  printf("xserver: callback_xserver_keystroke\n");
  
  //need to prepare screen dimensions
  scrnx=box->xmax-box->xmin;
  scrny=box->ymax-box->ymin;

  arglist=NULL;
  dynamic_putarg("std.void","xclient",x->callback,SZ,&arglist);
  dynamic_putarg("std.int","panel",(void *) &box->ipanel,SZ,&arglist);
  dynamic_putarg("std.int","scrnx",(void *) &scrnx,SZ,&arglist);
  dynamic_putarg("std.int","scrny",(void *) &scrny,SZ,&arglist);
  dynamic_putarg("std.char","command",(void *) &ch,SZ,&arglist);
  dynamic_call("xclient","xclient_callback_keystroke",'s',arglist,&callback);
  dynamic_wait(callback,NULL);
  dynamic_closeargs(arglist);
  //callback_xserver_keystroke(x->callback,box->ipanel,box->xmax-box->xmin,box->ymax-box->ymin,ch);
  //void callback_xserver_keystroke(void *p,int panel,int scrnx,int scrny,char command)

  //redraw box edges after completion of callback
  XSync(x->dis,False);
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,BLACK));
  XDrawRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin); 
  printf("xserver: redraw box edges\n");
}

void handle_text_command(xsrv *x,xbox *box,xbox *hbox,char ch)
{
  int ic;
  void *arglist;
  void *callback;
  xtxt *write;

  // *********************************************************** //
  // ** RESPOND APPROPRIATELY TO EVENTS IN THE TEXT INPUT BOX ** //
  // *********************************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,hbox)) return;

  draw_cursor(x,box,WHITE); //whiten current cursor
 
  if(ch==DELETE||ch==BACKSPACE)
  {
    if(box->wrtmem=='t')
    {
      if(invalidptr(E,box->write)) return;
      if(invalidptr(E,box->write[0])) return;
     
      write=box->write[0];
      
      //if delete or backspace key is pressed
      draw_cursor(x,box,WHITE);
      if(write->xcursor>box->xmin)
      {
        write->xcursor-=box->xfontsize;
        if(write->xcursor>=box->xmin)
          draw_cursor(x,box,MIDGREY);
      }
    
      if(write->nchars>0)
      {
        write->nchars--;
        if(write->nchars>=0)
          write->text[write->nchars]=STRINGEND;
      }

      if(write->xcursor<box->xmin&&
         box->ymin+write->ycursor<box->ymin+box->yfontsize) //only reset on first line
      {
        reset_cursor(x,box);
        draw_cursor(x,box,WHITE);
      }

      //retreat cursor by one line of text
      if(write->xcursor<box->xmin+box->xfontsize/2&&
         box->ymin+write->ycursor>box->ymin+box->yfontsize)
      {
        draw_cursor(x,box,WHITE);
        write->ycursor-=box->yfontsize;
        write->xcursor=box->xmin+box->xfontsize/2+write->linelen*box->xfontsize;
      }

      //printf("write->nchars=%d\n",write->nchars);
    }
  }
  else if(ch==CRETURN)
  { 
    //carriage return treated as end of command
    if(box->wrtmem=='t') 
    {
      if(invalidptr(E,box->write)) return;
      if(invalidptr(E,box->write[0])) return;

      write=box->write[0];

      write->text[write->nchars]=NEWLINE;

      arglist=NULL;
      dynamic_putarg("std.void","xclient",x->callback,SZ,&arglist); //size of x->callback data structure is not known by xserver
      dynamic_putarg("std.int","panel",(void *) &box->ipanel,SZ,&arglist);
      dynamic_putarg("std.int","nchars",(void *) &write->nchars,SZ,&arglist);
      dynamic_putarg("std.char","text",(void *) write->text,SZ,&arglist);
      dynamic_call("xclient","xclient_callback_command",'s',arglist,&callback);
      dynamic_wait(callback,NULL);
      dynamic_closeargs(arglist); 
      //callback_xserver_command(x->callback,box->ipanel,write->nchars,write->text); //send string to caller 
      //void callback_xserver_command(void *p,int panel,int nchars,char *text)
    }
    
    redraw_box(x,box);
    reset_cursor(x,box);
    draw_cursor(x,box,MIDGREY);
  }
  else
  {
    if(box->wrtmem=='f')
      init_text(x,box);
    
    if(box->wrtmem=='t')
    {
      if(invalidptr(E,box->write)) return;
      if(invalidptr(E,box->write[0])) return;

      write=box->write[0];

      //draw chracter, move cursor, and redraw
      if(write->xcursor<box->xmax-box->xfontsize*2)
      {
        draw_character(x,box,BLACK,ch);
        write->xcursor+=box->xfontsize;
      
        write->text[write->nchars]=ch;
        write->nchars++;
      }
    
      //newline
      if(write->xcursor>box->xmax-box->xfontsize*2&&
         box->ymin+write->ycursor<box->ymax-box->yfontsize*3) 
      {
        write->ycursor+=box->yfontsize;
        write->xcursor=box->xmin+box->xfontsize/2;
      }
    }

    draw_cursor(x,box,MIDGREY);
  }
}

void draw_character(xsrv *x,xbox *box,double shade,char ch)
{
  xtxt *write;

  // ********************************* //
  // ** PRINT A CHARACTER TO SCREEN ** //
  // ********************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  if(box->wrtmem=='t')
  {
    if(invalidptr(E,box->write)) return;
    if(invalidptr(E,box->write[0])) return;
    write=box->write[0];

    //print one character at a time
    XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,shade));
    XDrawString(x->dis,x->win,x->rgbgc,box->xmin+write->xcursor,box->ymin+write->ycursor+box->yfontsize,&ch,1);
  }
}

void draw_cursor(xsrv *x,xbox *box,double shade)
{
  xtxt *write;

  // **************************** //
  // ** PRINT CURSOR TO SCREEN ** //
  // **************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  //to set cursor position first time, we need to initialise text
  if(box->wrtmem=='f'&&shade==MIDGREY)
    init_text(x,box);

  if(box->wrtmem=='t')
  {
    if(invalidptr(E,box->write)) return;
    if(invalidptr(E,box->write[0])) return;
    write=box->write[0];

    //draw filled rectangle in front of characters
    XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,shade)); 
    XFillRectangle(x->dis,x->win,x->rgbgc,box->xmin+write->xcursor,box->ymin+write->ycursor+2,box->xfontsize,box->yfontsize+4);
  }
}

void reset_cursor(xsrv *x,xbox *box)
{
  xtxt *write;

  // **************************************** //
  // ** RETURN CURSOR TO START OF TEXT BOX ** //
  // **************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  if(box->wrtmem=='t')
  {
    if(invalidptr(E,box->write)) return;
    if(invalidptr(E,box->write[0])) return;
    write=box->write[0];
    if(invalidptr(E,write)) return;
    write->xcursor=box->xfontsize/2; //set (relative) starting cursor position
    write->ycursor=box->yfontsize/2;
  }
}

void draw_button_depress(xsrv *x,xbox *box)
{
  int nchars;
  int xpos;
  int ypos;
  int chamfer;
  xtxt *write;
  XPoint pt[4];

  // ********************** //
  // ** DRAW BUTTON DOWN ** //
  // ********************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  chamfer=BUTTONCHAMFER;
  
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,LIGHTGREY)); 
  XFillRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
  
  //top
  pt[0].x=box->xmin;         pt[0].y=box->ymin;
  pt[1].x=box->xmax;         pt[1].y=box->ymin;
  pt[2].x=box->xmax-chamfer; pt[2].y=box->ymin+chamfer;
  pt[3].x=box->xmin+chamfer; pt[3].y=box->ymin+chamfer;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,SHADOW));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);
  
  //left
  pt[0].x=box->xmin;         pt[0].y=box->ymin;
  pt[1].x=box->xmin+chamfer; pt[1].y=box->ymin+chamfer;
  pt[2].x=box->xmin+chamfer; pt[2].y=box->ymax-chamfer;
  pt[3].x=box->xmin;         pt[3].y=box->ymax;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,SHADOW));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);

  //bottom
  pt[0].x=box->xmin;         pt[0].y=box->ymax;
  pt[1].x=box->xmin+chamfer; pt[1].y=box->ymax-chamfer;
  pt[2].x=box->xmax+chamfer; pt[2].y=box->ymax-chamfer;
  pt[3].x=box->xmax;         pt[3].y=box->ymax;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,ILLUMINATED));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);
  
  //right
  pt[0].x=box->xmax;         pt[0].y=box->ymax;
  pt[1].x=box->xmax-chamfer; pt[1].y=box->ymax-chamfer;
  pt[2].x=box->xmax-chamfer; pt[2].y=box->ymin+chamfer;
  pt[3].x=box->xmax;         pt[3].y=box->ymin;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,ILLUMINATED));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);
  
  //limit characters to screen width
  if(box->wrtmem=='t')
  {
    write=box->write[0];

    nchars=write->nchars;
    if((box->xmax-box->xmin)/box->xfontsize<write->nchars) 
      nchars=(box->xmax-box->xmin)/box->xfontsize;
  
    xpos=((box->xmin+box->xmax)/2)-(box->xfontsize*nchars/2);
    ypos=(box->ymin+box->ymax)/2+box->yfontsize/3;

    XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,MIDGREY));
    XDrawString(x->dis,x->win,x->rgbgc,xpos,ypos,write->text,nchars);
  }

  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,BLACK));
  XDrawRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
  XFlush(x->dis);
}

void draw_button_release(xsrv *x,xbox *box)
{
  int nchars;
  int xpos;
  int ypos;
  int chamfer;
  xtxt *write;
  XPoint pt[4];

  // ******************** //
  // ** DRAW BUTTON UP ** //
  // ******************** //
  
  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
 
  //printf("xserver: draw button: context %c, panel=%d\n",box->ccontext,box->ipanel);

  chamfer=BUTTONCHAMFER;

  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,LIGHTGREY)); 
  XFillRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
  
  //top
  pt[0].x=box->xmin;         pt[0].y=box->ymin;
  pt[1].x=box->xmax;         pt[1].y=box->ymin;
  pt[2].x=box->xmax-chamfer; pt[2].y=box->ymin+chamfer;
  pt[3].x=box->xmin+chamfer; pt[3].y=box->ymin+chamfer;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,ILLUMINATED));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);
  
  //left
  pt[0].x=box->xmin;         pt[0].y=box->ymin;
  pt[1].x=box->xmin+chamfer; pt[1].y=box->ymin+chamfer;
  pt[2].x=box->xmin+chamfer; pt[2].y=box->ymax-chamfer;
  pt[3].x=box->xmin;         pt[3].y=box->ymax;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,ILLUMINATED));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);

  //bottom
  pt[0].x=box->xmin;         pt[0].y=box->ymax;
  pt[1].x=box->xmin+chamfer; pt[1].y=box->ymax-chamfer;
  pt[2].x=box->xmax+chamfer; pt[2].y=box->ymax-chamfer;
  pt[3].x=box->xmax;         pt[3].y=box->ymax;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,SHADOW));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);
  
  //right
  pt[0].x=box->xmax;         pt[0].y=box->ymax;
  pt[1].x=box->xmax-chamfer; pt[1].y=box->ymax-chamfer;
  pt[2].x=box->xmax-chamfer; pt[2].y=box->ymin+chamfer;
  pt[3].x=box->xmax;         pt[3].y=box->ymin;
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,SHADOW));
  XFillPolygon(x->dis,x->win,x->rgbgc,pt,4,Complex,CoordModeOrigin);
  
  //limit characters to screen width
  if(box->wrtmem=='t')
  {
    write=box->write[0];
  
    nchars=write->nchars;
    if((box->xmax-box->xmin)/box->xfontsize<write->nchars) 
      nchars=(box->xmax-box->xmin)/box->xfontsize;
  
    xpos=((box->xmin+box->xmax)/2)-(box->xfontsize*nchars/2);
    ypos=(box->ymin+box->ymax)/2+box->yfontsize/3;

    XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,BLACK));
    XDrawString(x->dis,x->win,x->rgbgc,xpos,ypos,write->text,nchars); 
  }

  XDrawRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
  XFlush(x->dis);
}

void handle_button_context(xsrv *x,xbox *wbox,char ccontext)
{
  int ibx,jbx;
  xbox *bbox;

  // ******************************************************* //
  // ** DECIDE WHICH CONTEXT-DEPENDENT BUTTON ROW TO DRAW ** //
  // ******************************************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,wbox)) return;
 
  //draw buttons in every button context (should only be one!)
  for(ibx=0;ibx<wbox->nsboxes;ibx++)
    if(wbox->submem=='t'&&!invalidptr(E,wbox->sbox))
      if(!invalidptr(E,wbox->sbox[ibx]))
	if(wbox->sbox[ibx]->ccontext=='b')
	{
	  //valid button context, so redraw bbox and populate
	  bbox=wbox->sbox[ibx];
          redraw_box(x,bbox);

          for(jbx=0;jbx<bbox->nsboxes;jbx++)
            if(bbox->submem=='t'&&!invalidptr(E,bbox->sbox))
	      if(!invalidptr(E,bbox->sbox[jbx]))
	        if(bbox->sbox[jbx]->ccontext==ccontext) //only draw buttons in the current proxy context
		  draw_button_release(x,bbox->sbox[jbx]);
        }
}

xbox *handle_mouse_panel(xsrv *x,xbox *box,int xmouse,int ymouse,int bmouse,char ccontext)
{
  int ibx;
  xbox *ret;
  
  // ******************************************** //
  // ** SELECT CONTEXT BY MOUSE CLICK ON PANEL ** //
  // ******************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  printf("xserver: xmouse=%d ymouse=%d ccontext=%c nsboxes=%d\n",xmouse,ymouse,ccontext,box->nsboxes);

  //find the panel on which the mouse has clicked 
  ret=NULL;
  for(ibx=0;ibx<box->nsboxes;ibx++)
    if(box->submem=='t'&&!invalidptr(E,box->sbox))
      if(mouse_in_box(x,box->sbox[ibx],xmouse,ymouse)=='t')
	if(!invalidptr(E,box->sbox[ibx]))
	  if(ccontext=='n')
	  {
	    ret=box->sbox[ibx];
	    printf("xserver: ibx=%d [%d:%d,%d:%d] ccontext=n box->ccontext=%c box->ipanel=%d\n",ibx,ret->xmin,ret->xmax,ret->ymin,ret->ymax,ret->ccontext,ret->ipanel);
	  }
	  else
	    if(box->sbox[ibx]->ccontext==ccontext) //pick up the panel only if matches the current context
            {
	      ret=box->sbox[ibx];
	      printf("xserver: [%d:%d,%d:%d] ccontext=%c box->ccontext=%c box->ipanel=%d\n",ret->xmin,ret->xmax,ret->ymin,ret->ymax,ccontext,ret->ccontext,ret->ipanel);
	    }
  
  if(!invalidptr(S,ret)) return ret;
  else return NULL;
}

void handle_cmd_mouse(void *arg1,void *arg2,void *arg3)
{
  int ic;
  int xmouse,ymouse,bmouse;
  char ccontext;
  int panel;
  char text[MAXLEN];
  xbox *box;
  xbox *hbox;
  xbox *bsbox;
  
  xsrv *x;
  xbox *wbox;
  xreq *carg;
  
  // **************************************************** //
  // ** RESPOND TO MOUSE CLICK BY POSITION AND CONTEXT ** //
  // **************************************************** //

  if(invalidptr(E,arg1)) return;
  if(invalidptr(E,arg2)) return;
  if(invalidptr(E,arg3)) return;
  
  x=(xsrv *) arg1;
  wbox=(xbox *) arg2;
  carg=(xreq *) arg3;

  xmouse=carg->xmouse;
  ymouse=carg->ymouse;
  bmouse=carg->bmouse;

  printf("xserver: calling handle_mouse_panel() from null context\n");
  box=NULL;
  box=handle_mouse_panel(x,wbox,xmouse,ymouse,bmouse,'n'); //pass NULL context since this click may change the context 
  hbox=handle_find_panel(x,wbox,'h',0);
 
  memset(text,0,sizeof(char)*MAXLEN);
 
  if(invalidptr(S,box))
  {
    sprintf(text,"click failed\n");
    handle_text_output(x,hbox,get_palette_grey(x,BLACK),hbox->ctr,str_length(text),text,'<'); 
    return;
  }
  else
  {
    if(box->ccontext=='b')
      sprintf(text,"context %c:%d active by proxy\n",box->ccontext,box->ipanel);
    else
      sprintf(text,"context %c:%d active\n",box->ccontext,box->ipanel);
    
    handle_text_output(x,hbox,get_palette_grey(x,BLACK),hbox->ctr,str_length(text),text,'<'); 
  }

  if(box->ccontext=='i')
  {
    handle_activate_panel(x,box); //swap active panel
    handle_clean_cursors(x,wbox); //wipe cursors in other windows
    handle_button_context(x,wbox,box->ccontext); //draw relevant buttons

    //image box actions
    if(box->ctr==0) 
    {
      //draw the image the first time or after refresh
      printf("xserver: handle_image_key\n");
      handle_image_key(x,box,hbox,'i');
    }
    else
    {
      //set up callbacks to return pixel string and then output the string to history
      handle_raster_pixel(x,box,xmouse,ymouse);
    }
    
    box->ctr++;
  }
  else if(box->ccontext=='c')
  {
    //a click in a command box makes keyboard text input active
    handle_activate_panel(x,box);
    handle_button_context(x,wbox,box->ccontext);
    
    if(box->ctr==0)
    {
      handle_clean_cursors(x,wbox);
      redraw_box(x,box);
      reset_cursor(x,box);
      draw_cursor(x,box,MIDGREY);
    }
    else
    {
      draw_cursor(x,box,MIDGREY);
    }

    box->ctr++;
  }
  else if(box->ccontext=='h')
  {
    handle_activate_panel(x,box);
    handle_clean_cursors(x,wbox);
    handle_button_context(x,wbox,box->ccontext);
    box->ctr++;
  }
  else if(box->ccontext=='b')
  {
    handle_current_context(x,wbox,&ccontext,&panel); 

    printf("xserver: button context, proxy context %c, panel %d\n",ccontext,panel);
    
    //find sub-box of bbox that matches context at this position
    bsbox=NULL;
    bsbox=handle_mouse_panel(x,box,xmouse,ymouse,bmouse,ccontext); 
    if(!invalidptr(S,bsbox)) 
      handle_button_click(x,bsbox,hbox,ccontext,panel);
    else
    {
      memset(text,0,sizeof(char)*MAXLEN);
      sprintf(text,"click failed\n");
      handle_text_output(x,hbox,get_palette_grey(x,BLACK),hbox->ctr,str_length(text),text,'<'); 
    }

    //don't change current context to 'b', since this would 
    //then require two clicks to re-click a button 
  }
  else
  {
    printf("xserver: nothing active\n");
    box=NULL;
    box=handle_current_panel(x,wbox);
    if(!invalidptr(E,box))
      box->active='f'; //deactivate active panel
    handle_clean_cursors(x,wbox); //wipe cursors
    handle_button_context(x,wbox,'n'); //wipe buttons
  }
}

void handle_button_click(xsrv *x,xbox *bbox,xbox *hbox,char ccontext,int panel)
{
  int ic;
  int nchars;
  char text[MAXLEN];
  xtxt *write;

  void *arglist;
  void *callback;

  // ***************************************************************** //
  // ** RESPOND TO BUTTON PRESS WITH REDRAW AND CLIENT NOTIFICATION ** //
  // ***************************************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,bbox)) return;
  if(invalidptr(E,hbox)) return;
  
  draw_button_depress(x,bbox);
  
  if(bbox->wrtmem=='t')
  {
    write=bbox->write[0];
    sprintf(text,"%s",write->text);
    nchars=str_length(text);
  }
  else
  {
    //ensure callback is valid in case wrtmem not allocated
    sprintf(text,"BUTTON");
    nchars=str_length(text);
  }
    
  arglist=NULL;
  dynamic_putarg("std.void","xclient",x->callback,SZ,&arglist); //size of x->callback data structure is not known by xserver
  dynamic_putarg("std.int","panel",(void *) &panel,SZ,&arglist);
  dynamic_putarg("std.char","context",(void *) &ccontext,SZ,&arglist);
  dynamic_putarg("std.int","button",(void *) &bbox->ibutton,SZ,&arglist);
  dynamic_putarg("std.int","nchars",(void *) &nchars,SZ,&arglist);
  dynamic_putarg("std.char","buttonname",(void *) text,SZ,&arglist);
  dynamic_call("xclient","xclient_callback_button",'s',arglist,&callback);
  dynamic_wait(callback,NULL);
  dynamic_closeargs(arglist);
  //callback_xserver_button(x->callback,panel,ccontext,bbox->ibutton,write->nchars,write->text);
  //void callback_xserver_button(void *p,int panel,char context,int button,int nchars,char *buttonname)
  
  draw_button_release(x,bbox);
  
  //record the click event in history.log
  memset(text,0,sizeof(char)*MAXLEN);

  if(bbox->wrtmem=='t')
  {
    write=bbox->write[0];
    sprintf(text,"button_%d%c%d '%s', for panel %d\n",bbox->ipanel,ccontext,bbox->ibutton,write->text,panel);
  }
  else
  {
    sprintf(text,"button_%d%c%d '%s', for panel %d\n",bbox->ipanel,ccontext,bbox->ibutton,"BUTTON",panel);
  }
    
  handle_text_output(x,hbox,get_palette_grey(x,BLACK),hbox->ctr,str_length(text),text,'>');
}

void handle_current_context(xsrv *x,xbox *box,char *ctxt,int *panel)
{
  int ibx;
  xbox *sbox;

  // *************************************** //
  // ** FIND ACTIVE PANEL AND ITS CONTEXT ** //
  // *************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  //find the active panel within this box and return its context
  for(ibx=0;ibx<box->nsboxes;ibx++)
    if(box->submem=='t'&&!invalidptr(E,box->sbox))
    {
      sbox=NULL;
      sbox=box->sbox[ibx];
      if(!invalidptr(E,sbox))
        if(sbox->active=='t')
	{
          *ctxt=sbox->ccontext;
	  *panel=sbox->ipanel;
	}
    }
}

void handle_activate_panel(xsrv *x,xbox *box)
{
  int ibx;
  xbox *sbox;

  // **************************** //
  // ** MAKE THIS PANEL ACTIVE ** //
  // **************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  //reset all panels to inactive
  for(ibx=0;ibx<x->wbox->nsboxes;ibx++)
    if(x->wbox->submem=='t'&&!invalidptr(E,x->wbox->sbox))
    {
      sbox=NULL;
      sbox=x->wbox->sbox[ibx];
      if(!invalidptr(E,sbox))
        sbox->active='f';
    }

  //activate the specified panel
  box->active='t';
}

xbox *handle_current_panel(xsrv *x,xbox *box)
{
  int ibx;
  xbox *sbox;
  xbox *ret;
  
  // *********************** //
  // ** FIND ACTIVE PANEL ** //
  // *********************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  //return active sub-box of input box
  ret=NULL;
  for(ibx=0;ibx<box->nsboxes;ibx++)
    if(box->submem=='t'&&!invalidptr(E,box->sbox))
    {
      sbox=NULL;
      sbox=box->sbox[ibx];
      if(!invalidptr(E,sbox))
        if(sbox->active=='t')
	  ret=sbox;
    }

  if(invalidptr(S,ret))
  {
    printf("xserver: box not found\n");
    return NULL;
  }
  else
  {
    return ret;
  }
}

xbox *handle_find_panel(xsrv *x,xbox *box,char ch,int panel)
{
  int ibx;
  char done;
  xbox *sbox;
  xbox *ret;

  // ***************************** //
  // ** SEARCH FOR ACTIVE PANEL ** //
  // ***************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  //return active sub-box of input box
  ret=NULL;
  done='f';
  for(ibx=0;ibx<box->nsboxes;ibx++)
    if(box->submem=='t'&&!invalidptr(E,box->sbox))
    { 
      sbox=NULL;
      sbox=box->sbox[ibx];
      if(!invalidptr(E,sbox))
        if(sbox->ccontext==ch&&sbox->ipanel==panel&&done=='f')
	{
          ret=sbox;
	  done='t';
	}
    }

  return ret;  
}

void handle_clean_cursors(xsrv *x,xbox *wbox)
{
  int ibx;

  // ************************ //
  // ** PAINT CURSOR WHITE ** //
  // ************************ //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,wbox)) return;
  
  for(ibx=0;ibx<wbox->nsboxes;ibx++)
    if(wbox->submem=='t'&&!invalidptr(E,wbox->sbox))
      if(!invalidptr(E,wbox->sbox[ibx]))
	if(wbox->sbox[ibx]->ccontext=='c')
          draw_cursor(x,wbox->sbox[ibx],WHITE); 
}

void redraw_box(xsrv *x,xbox *box)
{
  int ilyr;
  unsigned *hashes;

  // *************************************************** //
  // ** RELEASE BOX RESOURCES AND REDRAW FROM SCRATCH ** //
  // *************************************************** //

  //printf("xserver: redraw box\n");

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  XSetBackground(x->dis,x->rgbgc,get_palette_grey(x,WHITE));
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,WHITE));
  XFillRectangle(x->dis,x->win,x->rgbgc,box->xmin+1,box->ymin+1,box->xmax-box->xmin-1,box->ymax-box->ymin-1);
  XFillRectangle(x->dis,x->drgb,x->rgbgc,box->xmin+1,box->ymin+1,box->xmax-box->xmin-1,box->ymax-box->ymin-1);
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,BLACK));
  XDrawRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);

  if(box->wrtmem=='t')
    close_text(x,box);

  if(box->lyrmem=='t')
  {
    if(box->nlayers>0)
    {
      hashes=NULL;
      hashes=(unsigned *)imalloc(E,box->nlayers*sizeof(unsigned));

      if(!invalidptr(E,hashes))
      {
        //find all the layer names and store in an unmodified array
        if(!invalidptr(E,box->layer))
          for(ilyr=0;ilyr<box->nlayers;ilyr++)
	    if(!invalidptr(E,box->layer[ilyr]))
	      hashes[ilyr]=box->layer[ilyr]->hash;

        //close each by passing unique name of layer (indexing changes with each call)
        for(ilyr=0;ilyr<box->nlayers;ilyr++)
	  if(!invalidptr(E,box->layer[ilyr]))
            close_layer(x,box,NULL,hashes[ilyr]); 

        hashes=ifree(E,hashes);
      }
    }
  }
  //leave sub-box memory untouched for a simple redraw  
}

void handle_text_output(xsrv *x,xbox *box,unsigned long col,int ctr,int nchars,char *text,char inout)
{
  int screenmaxlines,filemaxlines;
  int screenmaxchars,filemaxchars;
  FILE *fptr;
  char *fline,*sline;
  int iline,nlines;
  int ic,cmatch,slen;
  int screenctr,filectr,newline;
  char chinout;
  xtxt *write;

  // ******************************************************* //
  // ** SEND TEXT TO LOG FILE AND OUTPUT TO HISTORY PANEL ** //
  // ******************************************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,text)) return;
  
  //clean start
  redraw_box(x,box);
  
  screenmaxlines=(int)((double) (box->ymax-box->ymin)/box->yfontsize)-1; //-1 offers a margin
  screenmaxchars=(int)((double) (box->xmax-box->xmin)/box->xfontsize)-1; //-1 offers a margin
  
  //read character size
  filemaxchars=HISTLINE;

  fline=NULL;
  sline=NULL;
  fline=(char *)imalloc(E,filemaxchars*sizeof(char));
  sline=(char *)imalloc(E,filemaxchars*sizeof(char));
  if(invalidptr(E,fline)) return;
  if(invalidptr(E,sline)) return;

  fptr=fopen("history.log","r");
  fseek(fptr,-filemaxchars,SEEK_END);
  fread(fline,sizeof(char),filemaxchars,fptr);
  fseek(fptr,0,SEEK_SET);
  fread(sline,sizeof(char),filemaxchars,fptr);
  fclose(fptr);
  
  //if only one line in file, then set filemaxlines=0
  cmatch=0;
  for(ic=0;ic<filemaxchars;ic++)
    if(sline[ic]==fline[ic]) cmatch++;
  if(cmatch==filemaxchars)
    filemaxlines=0;
  else
    sscanf(fline,"%c%04d %s\n",&chinout,&filemaxlines,sline);

  //append line
  filemaxlines++;
  fptr=fopen("history.log","a"); 
  for(ic=0;ic<filemaxchars;ic++) //wipe line
    fline[ic]=STRINGEND; 
  sprintf(fline,"%c%04d %s",inout,filemaxlines,text); //record whether input or output from request
  for(ic=nchars+HISTPREFIX;ic<filemaxchars;ic++) //pad with whitespace and add final carriage return
    fline[ic]=WHITESPACE;
  fline[filemaxchars-1]=NEWLINE;
  fwrite(fline,sizeof(char),filemaxchars,fptr);
  fclose(fptr);
  
  //printf("line: %s",fline);
  
  if(screenmaxlines<filemaxlines) nlines=screenmaxlines;
  else nlines=filemaxlines;

  //read from bottom of log file
  fptr=fopen("history.log","r");
  fseek(fptr,-filemaxchars,SEEK_END);

  screenctr=0;
  for(iline=0;iline<nlines;iline++)
  {
    fread(fline,sizeof(char),filemaxchars,fptr);
    fseek(fptr,-2*filemaxchars,SEEK_CUR);
      
    //strip out prefix log number and input/output specifier
    for(ic=HISTPREFIX;ic<filemaxchars;ic++)
      sline[ic-HISTPREFIX]=fline[ic];
      
    //strip out trailing newline
    newline=0;
    slen=filemaxchars;
    for(ic=0;ic<filemaxchars;ic++)
      if(sline[ic]==NEWLINE) 
      {
	sline[ic]=STRINGEND;
	slen=ic;
	newline=1;
      }

    //printf("newline=%d\n",newline);
    
    //truncate screen output to stay within box
    if(screenctr<screenmaxlines)
    {
      cmatch=0; 
      for(ic=0;ic<slen;ic++)
        if(sline[ic]!=WHITESPACE)
	  cmatch++;

      if(cmatch>screenmaxchars)
      {
        sline[screenmaxchars-3]='.';
        sline[screenmaxchars-2]='.';
        sline[screenmaxchars-1]='.';
        sline[screenmaxchars]=STRINGEND;
      }
    
      XSetForeground(x->dis,x->rgbgc,col);
      XDrawString(x->dis,x->win,x->rgbgc,
                  box->xmin+box->xfontsize,
	  	  box->ymax-(screenctr*box->yfontsize)-box->yfontsize/2,
		  sline,str_length(sline));
     
      screenctr+=newline;
    }
    
  }
  fclose(fptr);
   
  fline=ifree(E,fline);
  sline=ifree(E,sline);
}

void handle_raster_pixel(xsrv *x,xbox *box,int xmouse,int ymouse)
{
  int ix,iy,nx,ny,pc;
  double tx,ty;
  void *callback;
  void *arglist;

  // ********************************************* //
  // ** FIND IMAGE PROPERTIES AT MOUSE LOCATION ** //
  // ********************************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  nx=box->xmax-box->xmin;
  ny=box->ymax-box->ymin;
  
  //normalise mouse position with respect to sub-panel edges
  tx=(double)(xmouse-box->xmin)/nx;
  ty=(double)(ymouse-box->ymin)/ny;

  ix=(int) (tx*nx);
  iy=(int) (ty*ny);
  iy=ny-1-iy; //flip to right-handed coordinates

  printf("xserver: box[%d:%d,%d:%d] pixel[%d,%d]\n",box->xmin,box->xmax,box->ymin,box->ymax,ix,iy);

  arglist=NULL;
  dynamic_putarg("std.void","xclient",x->callback,SZ,&arglist); 
  dynamic_putarg("std.int","panel",(void *) &box->ipanel,SZ,&arglist);
  dynamic_putarg("std.int","scrnx",(void *) &nx,SZ,&arglist);
  dynamic_putarg("std.int","scrny",(void *) &ny,SZ,&arglist);
  dynamic_putarg("std.int","ix",(void *) &ix,SZ,&arglist);
  dynamic_putarg("std.int","iy",(void *) &iy,SZ,&arglist);
  dynamic_call("xclient","xclient_callback_pixelclick",'s',arglist,&callback);
  dynamic_wait(callback,NULL);
  dynamic_closeargs(arglist);
  //void callback_xserver_pixelclick(void *p,int panel,int scrnx,int scrny,int ix,int iy)
  //callback_xserver_pixelclick(x->callback,box->ipanel,nx,ny,ix,ny-1-iy); //flip to right-handed coordinates
  //screen output bounced from the callback is handled separately as a ClientMessage 
}

void handle_cmd_write(void *arg1,void *arg2,void *arg3)
{
  int ichar,pchar,nchars;
  char *charptr,*text;
  xbox *hbox;

  xsrv *x;
  xbox *wbox;
  xreq *carg;

  // ******************************** //
  // ** DRAW TEXT TO HISTORY PANEL ** //
  // ******************************** //

  if(invalidptr(E,arg1)) return;
  if(invalidptr(E,arg2)) return;
  if(invalidptr(E,arg3)) return;
  
  x=(xsrv *) arg1;
  wbox=(xbox *) arg2;
  carg=(xreq *) arg3;
  
  nchars=carg->ntext;
  text=carg->text;

  hbox=NULL;
  hbox=handle_find_panel(x,wbox,'h',0);
  
  if(!invalidptr(E,hbox))
  {
    //screen output is truncated at first \n, so parse for '\n'
    //printf("text: %s",text);
    charptr=text;
    pchar=0;
    for(ichar=0;ichar<nchars;ichar++)
    {
      if(text[ichar]==NEWLINE)
      {
        handle_text_output(x,hbox,get_palette_grey(x,BLACK),hbox->ctr,ichar-pchar,charptr,'<');
        pchar=ichar+1;
        charptr=text+ichar+1; //move pointer along string
      }
    }
  }

  carg->text=ifree(E,carg->text); //dislike doing this here, but prevents a memory leak.
}

void handle_cmd_draw(void *arg1,void *arg2,void *arg3)
{
  xbox *box;
  xbox *wbox;
  xreq *carg;
  xsrv *x;
  xlyr *lyr;

  // **************************************************** //
  // ** DRAW RASTER AND VECTOR GRAPHCS TO LAYER BUFFER ** //
  // **************************************************** //

  if(invalidptr(E,arg1)) return;
  if(invalidptr(E,arg2)) return;
  if(invalidptr(E,arg3)) return;
  
  x=(xsrv *)arg1;
  wbox=(xbox *)arg2;
  carg=(xreq *)arg3;

  box=NULL;
  box=handle_find_panel(x,wbox,'i',carg->panel);

  if(!invalidptr(E,box))
    if(box->ccontext=='i') //only draw within an image box
    {
      //search for a layer matching the name given
      lyr=NULL;
      if(box->lyrmem=='t')
        lyr=get_layer(x,box,carg->layer,NULL);

      if(!invalidptr(S,lyr)) //simply memory protection
      {
        if(carg->cmd==str_hash("drawline"))         draw_polyline(x,box,lyr,carg->npts,carg->xpt,carg->ypt,carg->size,carg->red,carg->green,carg->blue,carg->alpha,carg->fill);
        else if(carg->cmd==str_hash("drawcircle"))  draw_polycircle(x,box,lyr,carg->npts,carg->xpt,carg->ypt,carg->size,carg->red,carg->green,carg->blue,carg->alpha,carg->fill);
        else if(carg->cmd==str_hash("drawsquare"))  draw_polysquare(x,box,lyr,carg->npts,carg->xpt,carg->ypt,carg->size,carg->red,carg->green,carg->blue,carg->alpha,carg->fill);
        else if(carg->cmd==str_hash("drawpolygon")) draw_polygon(x,box,lyr,carg->npts,carg->xpt,carg->ypt,carg->size,carg->red,carg->green,carg->blue,carg->alpha,carg->fill);
        else if(carg->cmd==str_hash("drawraster"))  draw_raster(x,box,lyr,carg->nx,carg->ny,carg->red,carg->green,carg->blue,carg->alpha);
      }
    }
}

void handle_cmd_layer(void *arg1,void *arg2,void *arg3)
{
  int ilyr;
  int iold;
  int inew;
  int nvisible;
  xbox *box;
  xbox *wbox;
  xreq *carg;
  xsrv *x;
  xlyr *lyr;

  // ******************************************************* //
  // ** INTERPRETER OF CLIENT COMMANDS FOR IMAGE LAYERING ** //
  // ******************************************************* //

  if(invalidptr(E,arg1)) return;
  if(invalidptr(E,arg2)) return;
  if(invalidptr(E,arg3)) return;
  
  x=(xsrv *)arg1;
  wbox=(xbox *)arg2;
  carg=(xreq *)arg3;
  
  box=NULL;
  box=handle_find_panel(x,wbox,'i',carg->panel);

  if(!invalidptr(E,box))
    if(box->ccontext=='i') //only reveal layer within confines of an image box
    {
      if(carg->cmd==str_hash("layerinit"))
      { 
        // ********************** //
	// ** INITIALISE LAYER ** //
	// ********************** //
	
        printf("xserver: handle_cmd_layer: layerinit\n");
	
	lyr=NULL;
	if(box->lyrmem=='t'&&!invalidptr(E,box->layer)) 
          lyr=get_layer(x,box,carg->layer,NULL);

        if(invalidptr(S,lyr))  //if layer name unmatched in layer list, then create a new layer
          init_layer(x,box,carg->layer,carg->type); //add new layer to list
      }
      else if(carg->cmd==str_hash("layerwipe"))
      {
        // ********************** //
	// ** WIPE LAYER CLEAN ** //
	// ********************** //

        printf("xserver: handle_cmd_layer: layerwipe\n");
        
	if(box->lyrmem=='t'&&!invalidptr(E,box->layer))
	{
	  lyr=NULL;
	  lyr=get_layer(x,box,carg->layer,NULL);
        
	  if(!invalidptr(E,lyr))
            draw_clear(x,box,lyr); //clear
        } 
      }
      else if(carg->cmd==str_hash("layerclose"))
      {
        // ************************** //
	// ** RELEASE LAYER MEMORY ** //
	// ************************** //

        printf("xserver: handle_cmd_layer: layerclose\n");
       
        if(box->lyrmem=='t'&&!invalidptr(E,box->layer))
	{
          lyr=NULL;
	  lyr=get_layer(x,box,carg->layer,NULL);
        
	  if(!invalidptr(E,lyr))
	    close_layer(x,box,lyr,0); 
        }
      }
      else if(carg->cmd==str_hash("layertransfer"))
      {
        // ******************************************** //
	// ** RETRIEVE SCREEN DOUBLE BUFFER TO LAYER ** //
	// ******************************************** //
	
        printf("xserver: handle_cmd_layer: layertransfer: %u\n",carg->layer);

        if(box->lyrmem=='t'&&!invalidptr(E,box->layer))
	{
          lyr=NULL;
	  lyr=get_layer(x,box,carg->layer,NULL);
	  
	  if(!invalidptr(E,lyr)) 
	  {
            printf("xserver: copy dbuf to layer %u\n",carg->layer,box->xmin,box->xmax,box->ymin,box->ymax);
        
            XSetClipOrigin(x->dis,x->rgbgc,box->xmin,box->ymin);
	    XSetClipMask(x->dis,x->rgbgc,x->dmask);
            XCopyArea(x->dis,x->drgb,lyr->rgb,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin,0,0); 
            XSetClipMask(x->dis,x->rgbgc,None);
	    
            XSetClipOrigin(x->dis,x->alphagc,box->xmin,box->ymin);
	    XSetClipMask(x->dis,x->alphagc,x->dmask);
            XCopyArea(x->dis,x->dalpha,lyr->alpha,x->alphagc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin,0,0); 
            XSetClipMask(x->dis,x->alphagc,None);
	    
            XSetClipOrigin(x->dis,x->maskgc,box->xmin,box->ymin);
	    XSetClipMask(x->dis,x->maskgc,x->dmask);
            XCopyArea(x->dis,x->dmask,lyr->mask,x->maskgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin,0,0); 
            XSetClipMask(x->dis,x->maskgc,None);
          }
	}
      }
      else if(carg->cmd==str_hash("layerexpose"))
      { 
        // ****************************************** //
	// ** EXPOSE LAYER TO SCREEN DOUBLE BUFFER ** //
	// ****************************************** //

        printf("xserver: handle_cmd_layer: layerexpose: %u %c\n",carg->layer,carg->logic);
        
        if(box->lyrmem=='t'&&!invalidptr(E,box->layer))
	{
          lyr=NULL;
	  lyr=get_layer(x,box,carg->layer,NULL);

          nvisible=reorder_layer(x,box,carg->layer);

	  if(!invalidptr(E,lyr)) 
	  {
            printf("xserver: copy layer %u to dbuf [%d:%d,%d:%d]\n",carg->layer,box->xmin,box->xmax,box->ymin,box->ymax);

	    handle_layer2dbuf(x,box,lyr,carg->logic); //true to debug render

	    lyr->visible='t';
	    lyr->vieworder=nvisible;
	    lyr->viewlogic=carg->logic;
	  }
      
         //printf("expose: %u\n",carg->layer);
         //for(ilyr=0;ilyr<box->nlayers;ilyr++)
         //  printf("expose: name: %u order: %d %c\n",box->layer[ilyr]->hash,box->layer[ilyr]->vieworder,box->layer[ilyr]->visible);
	}
      }
      else if(carg->cmd==str_hash("layerconceal"))
      {
        // ********************************************* //
	// ** CONCEAL LAYER FROM SCREEN DOUBLE BUFFER ** //
	// ********************************************* //

        printf("xserver: handle_cmd_layer: layerconceal: %u\n",carg->layer);

        if(box->lyrmem=='t'&&!invalidptr(E,box->layer))
	{
	  nvisible=reorder_layer(x,box,carg->layer);
       
          //wipe double buffer, alpha channel and mask to start afresh
          handle_dbufclean(x,box);
 
	  for(iold=0;iold<nvisible+1;iold++)
          {
            for(ilyr=0;ilyr<box->nlayers;ilyr++)
	      if(!invalidptr(E,box->layer[ilyr]))
                if(box->layer[ilyr]->vieworder==iold&&box->layer[ilyr]->visible=='t')
	        {
		  lyr=box->layer[ilyr];

	          inew=iold;
	          if(!invalidptr(E,lyr)) 
	          {
                    printf("xserver: copy layer %u to dbuf\n",carg->layer,box->xmin,box->xmax,box->ymin,box->ymax);

                    handle_layer2dbuf(x,box,lyr,lyr->viewlogic);

		    lyr->visible='t';
		    lyr->vieworder=inew;
	          }
	        }
          }
         
	 //printf("conceal: %u\n",carg->layer);
         //for(ilyr=0;ilyr<box->nlayers;ilyr++)
         //  printf("conceal: name: %u order: %d %c\n",box->layer[ilyr]->hash,box->layer[ilyr]->vieworder,box->layer[ilyr]->visible);
	}
      }
      else if(carg->cmd==str_hash("layergrab"))
      {
        // ************************************ //
	// ** PASS LAYER RGBA DATA TO CLIENT ** //
	// ************************************ //

        printf("xserver: handle_cmd_layer: layergrab: %u\n",carg->layer);
        
	if(box->lyrmem=='t')
	{	  
          lyr=NULL;
	  lyr=get_layer(x,box,carg->layer,NULL);
 
          if(!invalidptr(E,lyr))
	    handle_layer2client(x,box,carg->layer,lyr->rgb,lyr->alpha,lyr->mask);
	}
      }
    }
}

void handle_cmd_screen(void *arg1,void *arg2,void *arg3)
{
  int ibox;
  xbox *box;
  xbox *wbox;
  xreq *carg;
  xsrv *x;

  // ************************************************************** //
  // ** RESPOND TO CLIENT REQUEST TO UPDATE, COPY OR WIPE SCREEN ** //
  // ************************************************************** //

  if(invalidptr(E,arg1)) return;
  if(invalidptr(E,arg2)) return;
  if(invalidptr(E,arg3)) return;
  
  x=(xsrv *)arg1;
  wbox=(xbox *)arg2;
  carg=(xreq *)arg3;
  
  XSync(x->dis,False);

  //search for image sub-boxes, and update those
  //for(ibox=0;ibox<x->wbox->nsboxes;ibox++)
  {
    box=NULL;
    box=handle_find_panel(x,wbox,'i',carg->panel);

    if(!invalidptr(E,box))
      if(box->ccontext=='i') //only update parts of screen that are covered by context 'i' (all the rest are updated directly)
      {
        if(carg->cmd==str_hash("screenupdate"))
        {
          printf("xserver: handle_cmd_screen: screenupdate panel %d [%d:%d,%d:%d]\n",carg->panel,box->xmin,box->xmax,box->ymin,box->ymax);
          XSetClipMask(x->dis,x->rgbgc,None);
	  XCopyArea(x->dis,x->drgb,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin,box->xmin,box->ymin);
         
	  //XSync(x->dis,False);

	  //redraw box edges
          XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,BLACK));
          XDrawRectangle(x->dis,x->win,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin); 
          printf("xserver: redraw box edges\n");
        }
        else if(carg->cmd==str_hash("screenclean"))
        {
          printf("xserver: handle_cmd_screen: screenclean\n");
          
	  handle_dbufclean(x,box);
        }
	else if(carg->cmd==str_hash("screengrab")) 
	{
	  //grab double buffer (bit more flexible than the screen itself)
          printf("xserver: handle_cmd_screen: screengrab\n");
          
          handle_layer2client(x,box,str_hash("screen"),x->drgb,x->dalpha,x->dmask);
	}
      }
  }

  XSync(x->dis,False);
}

void handle_dbufclean(xsrv *x,xbox *box)
{
  // ******************************** //
  // ** RESET SCREEN DOUBLE BUFFER ** //
  // ******************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  printf("xserver: cleaning double buffer for box [%d:%d,%d:%d]\n",box->xmin,box->xmax,box->ymin,box->ymax);

  XSetClipMask(x->dis,x->rgbgc,None);
  XSetForeground(x->dis,x->rgbgc,get_palette_grey(x,WHITE));
  XFillRectangle(x->dis,x->drgb,x->rgbgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
          
  XSetClipMask(x->dis,x->alphagc,None);
  XSetForeground(x->dis,x->alphagc,get_palette_grey(x,BLACK));
  XFillRectangle(x->dis,x->dalpha,x->alphagc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
         
  XSetClipMask(x->dis,x->maskgc,None);
  XSetForeground(x->dis,x->maskgc,0);
  XFillRectangle(x->dis,x->dmask,x->maskgc,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin);
}

void handle_layer2dbuf(xsrv *x,xbox *box,xlyr *lyr,char render)
{
  XImage *imlyrrgb,*imlyralpha;
  XImage *imdrgb,*imdalpha;
  int k;
  uint8_t chlr,chlg,chlb,chla;
  uint8_t chdr,chdg,chdb,chda;
  double lred,lgreen,lblue,lalpha;
  double dred,dgreen,dblue,dalpha; 

  // ************************************************************ //
  // ** COPY OR ACCUMULATE IMAGE LAYER TO SCREEN DOUBLE BUFFER ** //
  // ************************************************************ //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;

  if(render=='e')
  {
    printf("xserver: expose layer %u to double buffer [%d:%d,%d:%d]\n",lyr->hash,box->xmin,box->xmax,box->ymin,box->ymax);

    //straightforward, efficient server-side exposure of layer on top of all previous layers in the double buffer
    XSetClipOrigin(x->dis,lyr->rgbgc,box->xmin,box->ymin);
    XSetClipMask(x->dis,lyr->rgbgc,lyr->mask); //only copy pixels relevant to this layer (for transparency with other layers)
    XCopyArea(x->dis,lyr->rgb,x->drgb,lyr->rgbgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin,box->xmin,box->ymin); 
    XSetClipMask(x->dis,lyr->rgbgc,None);

    //expose relevant parts of alpha channel
    XSetClipOrigin(x->dis,lyr->alphagc,box->xmin,box->ymin);
    XSetClipMask(x->dis,lyr->alphagc,lyr->mask);
    XCopyArea(x->dis,lyr->alpha,x->dalpha,lyr->alphagc,0,0,box->xmax-box->xmin,box->ymax-box->ymin,box->xmin,box->ymin); 
    XSetClipMask(x->dis,lyr->alphagc,None);
	    
    //draw this bit of the lyr mask onto the double buffer mask
    XSetClipOrigin(x->dis,lyr->maskgc,box->xmin,box->ymin);
    XSetClipMask(x->dis,lyr->maskgc,lyr->mask);
    XCopyArea(x->dis,lyr->mask,x->dmask,lyr->maskgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin,box->xmin,box->ymin); 
    XSetClipMask(x->dis,lyr->maskgc,None);
  }
  else
  {
    //server to client transfer of rgb and alpha for dbuf and lyr 
    imlyrrgb=XGetImage(x->dis,lyr->rgb,0,0,box->xmax-box->xmin,box->ymax-box->ymin,XAllPlanes(),ZPixmap);
    imlyralpha=XGetImage(x->dis,lyr->alpha,0,0,box->xmax-box->xmin,box->ymax-box->ymin,XAllPlanes(),ZPixmap);
    imdrgb=XGetImage(x->dis,x->drgb,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin,XAllPlanes(),ZPixmap);
    imdalpha=XGetImage(x->dis,x->dalpha,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin,XAllPlanes(),ZPixmap);
    
    //fix masks because XGetImage can't be bothered...
    imlyrrgb->red_mask=x->red_mask;
    imlyrrgb->green_mask=x->green_mask;
    imlyrrgb->blue_mask=x->blue_mask;
    imlyralpha->red_mask=x->red_mask;
    imlyralpha->green_mask=x->green_mask;
    imlyralpha->blue_mask=x->blue_mask;
    imdrgb->red_mask=x->red_mask;
    imdrgb->green_mask=x->green_mask;
    imdrgb->blue_mask=x->blue_mask;
    imdalpha->red_mask=x->red_mask;
    imdalpha->green_mask=x->green_mask;
    imdalpha->blue_mask=x->blue_mask;

    //for every pixel, apply alpha compositing
    for(k=0;k<(box->xmax-box->xmin)*(box->ymax-box->ymin);k++)
    {
      //alpha MUST come before RGB to re-use red and green variables
      put_raster_rgb(x,imlyralpha,*((unsigned int *) imlyralpha->data+k),&chlr,&chlg,&chla); 
      put_raster_rgb(x,imlyrrgb,*((unsigned int *) imlyrrgb->data+k),&chlr,&chlg,&chlb);
      put_raster_rgb(x,imdalpha,*((unsigned int *) imdalpha->data+k),&chdr,&chdg,&chda); 
      put_raster_rgb(x,imdrgb,*((unsigned int *) imdrgb->data+k),&chdr,&chdg,&chdb);
      
      //pre-multiply by alpha and convert to double
      dalpha=((double) chda/CHWHITE);
      dred=((double) chdr/CHWHITE)*dalpha;
      dgreen=((double) chdg/CHWHITE)*dalpha;
      dblue=((double) chdb/CHWHITE)*dalpha;

      lalpha=((double) chla/CHWHITE);
      lred=((double) chlr/CHWHITE)*lalpha;
      lgreen=((double) chlg/CHWHITE)*lalpha;
      lblue=((double) chlb/CHWHITE)*lalpha;

      //decide blending operation based on render logic
      if(render=='p') //paint over
      {
        //blending operation
        dalpha=lalpha+dalpha*(1.0-lalpha);
        dred=lred+dred*(1.0-lalpha);
        dgreen=lgreen+dgreen*(1.0-lalpha);
        dblue=lblue+dblue*(1.0-lalpha);
      }
      else if(render=='i') //in
      {
        dred=lred*dalpha;
        dgreen=lgreen*dalpha;
        dblue=lblue*dalpha;
        dalpha=lalpha*dalpha; //alpha is modified AFTER use with RGB
      }
      else if(render=='o') //out
      {
        dred=lred*(1.0-dalpha);
        dgreen=lgreen*(1.0-dalpha);
        dblue=lblue*(1.0-dalpha);
        dalpha=lalpha*(1.0-dalpha); //alpha is modified AFTER use with RGB
      }
      else if(render=='t') //atop
      {
        dred=lred*dalpha+dred*(1.0-lalpha);
        dgreen=lgreen*dalpha+dgreen*(1.0-lalpha);
        dblue=lblue*dalpha+dblue*(1.0-lalpha);
        dalpha=lalpha*dalpha+dalpha*(1.0-lalpha); //alpha is modified AFTER use with RGB
      }
      else if(render=='x') //xor
      {
        dalpha=lalpha+(1.0-dalpha)+dalpha*(1.0-lalpha);
        dred=lred+(1.0-dred)+dred*(1.0-lred);
        dgreen=lgreen+(1.0-dgreen)+dgreen*(1.0-lgreen);
        dblue=lblue+(1.0-dblue)+dblue*(1.0-lblue);
      }

      //not sure unsigned int is the correct format conversion!!!
      *((unsigned int *) imdrgb->data+k)=(unsigned int) get_raster_rgb(x,imdrgb,(uint8_t) (dred*CHWHITE),(uint8_t) (dgreen*CHWHITE),(uint8_t) (dblue*CHWHITE)); 
      *((unsigned int *) imdalpha->data+k)=(unsigned int) get_raster_rgb(x,imdalpha,CHWHITE,CHWHITE,(uint8_t) (dalpha*CHWHITE)); 
    }
    
    //client to server transfer of dbuf only
    XSetClipMask(x->dis,x->rgbgc,None);
    XSetClipMask(x->dis,x->alphagc,None);
    XPutImage(x->dis,x->drgb,x->rgbgc,imdrgb,0,0,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin); 
    XPutImage(x->dis,x->dalpha,x->alphagc,imdalpha,0,0,box->xmin,box->ymin,box->xmax-box->xmin,box->ymax-box->ymin); 
    
    XDestroyImage(imlyrrgb);
    XDestroyImage(imlyralpha);
    XDestroyImage(imdrgb);
    XDestroyImage(imdalpha);

    //draw this bit of the lyr mask onto the double buffer mask - as though exposing rather than rendering
    XSetClipOrigin(x->dis,lyr->maskgc,box->xmin,box->ymin);
    XSetClipMask(x->dis,lyr->maskgc,lyr->mask);
    XCopyArea(x->dis,lyr->mask,x->dmask,lyr->maskgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin,box->xmin,box->ymin); 
    XSetClipMask(x->dis,lyr->maskgc,None);
  }
}

void handle_layer2client(xsrv *x,xbox *box,unsigned lyrhash,Pixmap lyr_rgb,Pixmap lyr_alpha,Pixmap lyr_mask)
{
  XImage *imrgb,*imalpha;
  int width,height,ix,iy,userpt,screenpt;
  uint8_t *red,*green,*blue,*alpha;
  void *arglist;
  void *callback;
  
  // ************************************************* //
  // ** BRING RGB IMAGE FROM SERVER LAYER TO CLIENT ** //
  // ************************************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  imrgb=XGetImage(x->dis,lyr_rgb,0,0,box->xmax-box->xmin,box->ymax-box->ymin,XAllPlanes(),ZPixmap);
  imrgb->red_mask=x->red_mask; //for some reason XGetImage() forgets to populate the masks!
  imrgb->green_mask=x->green_mask;
  imrgb->blue_mask=x->blue_mask;
          
  imalpha=XGetImage(x->dis,lyr_alpha,0,0,box->xmax-box->xmin,box->ymax-box->ymin,XAllPlanes(),ZPixmap);
  imalpha->red_mask=x->red_mask;
  imalpha->green_mask=x->green_mask;
  imalpha->blue_mask=x->blue_mask;

  width=box->xmax-box->xmin;
  height=box->ymax-box->ymin;

  red=NULL;
  green=NULL;
  blue=NULL;
  alpha=NULL;
  red=(uint8_t *)imalloc(E,width*height*sizeof(uint8_t));
  green=(uint8_t *)imalloc(E,width*height*sizeof(uint8_t));
  blue=(uint8_t *)imalloc(E,width*height*sizeof(uint8_t));
  alpha=(uint8_t *)imalloc(E,width*height*sizeof(uint8_t));
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;

  for(ix=0;ix<width;ix++)
    for(iy=0;iy<height;iy++)
    {
      //userpt=ix+(height-1-iy)*width; //flip to right-handed coordinates seems not to be necessary! 
      userpt=ix+iy*width; 
      screenpt=ix+iy*width;
  
      //use same rgb conversion utility for alpha channel, but only use 8-bit blue information for transparency
      //(conversion of alpha to uint8_t  MUST be before RGB to reuse red and green memory safely)
      //not sure unsigned int is the correct format conversion!!!
      put_raster_rgb(x,imalpha,*((unsigned int *) imalpha->data+screenpt),&(red[userpt]),&(green[userpt]),&(alpha[userpt])); 
      put_raster_rgb(x,imrgb,*((unsigned int *) imrgb->data+screenpt),&(red[userpt]),&(green[userpt]),&(blue[userpt])); 
    }

  arglist=NULL;
  dynamic_putarg("std.void","xclient",x->callback,SZ,&arglist); //size of x->callback data structure is not known by xserver
  dynamic_putarg("std.int","panel",(void *) &box->ipanel,SZ,&arglist);
  dynamic_putarg("std.unsigned","lyrhash",(void *) &lyrhash,SZ,&arglist);
  dynamic_putarg("std.int","scrnx",(void *) &width,SZ,&arglist);
  dynamic_putarg("std.int","scrny",(void *) &height,SZ,&arglist);
  dynamic_putarg("std.uint8_t","red",(void *) red,SZ,&arglist);
  dynamic_putarg("std.uint8_t","green",(void *) green,SZ,&arglist);
  dynamic_putarg("std.uint8_t","blue",(void *) blue,SZ,&arglist);
  dynamic_putarg("std.uint8_t","alpha",(void *) alpha,SZ,&arglist);
  dynamic_call("xclient","xclient_callback_layergrab",'s',arglist,&callback);
  dynamic_wait(callback,NULL);
  dynamic_closeargs(arglist);
  //callback_xserver_layergrab(x->callback,box->ipanel,lyrhash,width,height,red,green,blue,alpha);
  //void callback_xserver_layergrab(void *p,int panel,unsigned lyrhash,int scrnx,int scrny,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha)
	  
  XDestroyImage(imrgb);
  XDestroyImage(imalpha);
  //RGBA arrays are left to the user manage in client space, user MUST ifree these themselves
}

void draw_polycircle(xsrv *x,xbox *box,xlyr *lyr,int npts,int *xc,int *yc,int *rad,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha,char drawtype)
{
  int ipt;
  int xcorn,ycorn;
  int axmaj,axmin;
  int angstart,angend;

  // ****************************************** //
  // ** DRAW LIST OF VECTOR GRAPHICS CIRCLES ** //
  // ****************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;

  printf("xserver: draw_polycircle\n");

  for(ipt=0;ipt<npts;ipt++)
  {
    xcorn=xc[ipt]-rad[ipt];
    ycorn=yc[ipt]-rad[ipt];
    axmaj=2*rad[ipt];
    axmin=2*rad[ipt];
    angstart=0;
    angend=360*64;

    if(drawtype=='f') //fill
    {
      XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt])); //rgb
      XFillArc(x->dis,lyr->rgb,lyr->rgbgc,xcorn,ycorn,axmaj,axmin,angstart,angend);
      
      XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  //alpha
      XFillArc(x->dis,lyr->alpha,lyr->alphagc,xcorn,ycorn,axmaj,axmin,angstart,angend);
      
      XSetForeground(x->dis,lyr->maskgc,1);                                               //mask
      XFillArc(x->dis,lyr->mask,lyr->maskgc,xcorn,ycorn,axmaj,axmin,angstart,angend);  
    }
    else if(drawtype=='p') //perimeter
    {
      XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt]));
      XDrawArc(x->dis,lyr->rgb,lyr->rgbgc,xcorn,ycorn,axmaj,axmin,angstart,angend);
      
      XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  
      XDrawArc(x->dis,lyr->alpha,lyr->alphagc,xcorn,ycorn,axmaj,axmin,angstart,angend);
      
      XSetForeground(x->dis,lyr->maskgc,1);
      XDrawArc(x->dis,lyr->mask,lyr->maskgc,xcorn,ycorn,axmaj,axmin,angstart,angend);
    }
  }
}

void draw_polysquare(xsrv *x,xbox *box,xlyr *lyr,int npts,int *xc,int *yc,int *side,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha,char drawtype)
{
  int ipt;
  int xcorn,ycorn;
  int halfside;

  // ****************************************** //
  // ** DRAW LIST OF VECTOR GRAPHICS SQUARES ** //
  // ****************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;
  if(invalidptr(E,xc)) return;
  if(invalidptr(E,yc)) return;
  if(invalidptr(E,side)) return;
  
  printf("xserver: draw_polysquare, npts=%d\n",npts);

  for(ipt=0;ipt<npts;ipt++)
  {
    halfside=side[ipt];
    xcorn=xc[ipt]-halfside;
    ycorn=yc[ipt]-halfside;
   
//printf("xcorn=%d ycorn=%d side=%d\n",xcorn,ycorn,2*halfside);
//printf("fill=%c red=%d green=%d blue=%d\n",drawtype,red[ipt],green[ipt],blue[ipt]);

    if(drawtype=='f')
    {
      XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt]));
      XFillRectangle(x->dis,lyr->rgb,lyr->rgbgc,xcorn,ycorn,2*halfside,2*halfside);
      
      XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  
      XFillRectangle(x->dis,lyr->alpha,lyr->alphagc,xcorn,ycorn,2*halfside,2*halfside);
      
      XSetForeground(x->dis,lyr->maskgc,1);
      XFillRectangle(x->dis,lyr->mask,lyr->maskgc,xcorn,ycorn,2*halfside,2*halfside);
    }
    else if(drawtype=='p') 
    {
      XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt]));
      XDrawRectangle(x->dis,lyr->rgb,lyr->rgbgc,xcorn,ycorn,2*halfside,2*halfside);
      
      XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  
      XDrawRectangle(x->dis,lyr->alpha,lyr->alphagc,xcorn,ycorn,2*halfside,2*halfside);
      
      XSetForeground(x->dis,lyr->maskgc,1);
      XDrawRectangle(x->dis,lyr->mask,lyr->maskgc,xcorn,ycorn,2*halfside,2*halfside);
    }
  }
}

void draw_polygon(xsrv *x,xbox *box,xlyr *lyr,int npts,int *xpt,int *ypt,int *size,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha,char drawtype)
{
  int ipt;
  XPoint *pt;

  // ********************************** //
  // ** DRAW VECTOR GRAPHICS POLYGON ** //
  // ********************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;
  if(invalidptr(E,xpt)) return;
  if(invalidptr(E,ypt)) return;
  
  pt=NULL;
  pt=(XPoint *)imalloc(E,npts*sizeof(XPoint));
  if(invalidptr(E,pt)) return;
 
  for(ipt=0;ipt<npts;ipt++)
  {
    pt[ipt].x=xpt[ipt];
    pt[ipt].y=ypt[ipt];
  }

  if(drawtype='f')
  {
    XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt]));
    XFillPolygon(x->dis,lyr->rgb,lyr->rgbgc,pt,npts,Complex,CoordModeOrigin);
    
    XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  
    XFillPolygon(x->dis,lyr->alpha,lyr->alphagc,pt,npts,Complex,CoordModeOrigin);
    
    XSetForeground(x->dis,lyr->maskgc,1);
    XFillPolygon(x->dis,lyr->mask,lyr->maskgc,pt,npts,Complex,CoordModeOrigin);
  }
  else if(drawtype=='p')
  {
    XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt]));
    XDrawPolygon(x->dis,lyr->rgb,lyr->rgbgc,pt,npts,Complex,CoordModeOrigin);
    
    XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  
    XDrawPolygon(x->dis,lyr->alpha,lyr->alphagc,pt,npts,Complex,CoordModeOrigin);
    
    XSetForeground(x->dis,lyr->maskgc,1);
    XDrawPolygon(x->dis,lyr->mask,lyr->maskgc,pt,npts,Complex,CoordModeOrigin);
  }

  pt=ifree(E,pt);
}

void draw_polyline(xsrv *x,xbox *box,xlyr *lyr,int npts,int *xpt,int *ypt,int *size,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha,char drawtype)
{
  int ipt;
  int xstart,ystart;
  int xend,yend;

  // ************************************************ //
  // ** DRAW LIST OF VECTOR GRAPHICS LINE SEGMENTS ** //
  // ************************************************ //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;
  if(invalidptr(E,xpt)) return;
  if(invalidptr(E,ypt)) return;
  
/*
  //set clipping her for debugging
  XSetClipMask(x->dis,lyr->rgbgc,None);
  XSetClipMask(x->dis,lyr->alphagc,None);
  XSetClipMask(x->dis,lyr->maskgc,None);
  
  XSetForeground(x->dis,lyr->rgbgc,get_palette_grey(x,WHITE));
  XFillRectangle(x->dis,lyr->rgb,lyr->rgbgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
    
  XSetForeground(x->dis,lyr->alphagc,get_palette_grey(x,BLACK));
  XFillRectangle(x->dis,lyr->alpha,lyr->alphagc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
  
  XSetForeground(x->dis,lyr->maskgc,0);
  XFillRectangle(x->dis,lyr->mask,lyr->maskgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
*/
  for(ipt=1;ipt<npts;ipt++)
  {
    xstart=xpt[ipt-1];
    ystart=ypt[ipt-1];
    xend=xpt[ipt];
    yend=ypt[ipt];

    if(drawtype=='f')  //continuous line
    {
      XSetLineAttributes(x->dis,lyr->rgbgc,size[ipt],LineSolid,CapButt,JoinRound);
      XSetLineAttributes(x->dis,lyr->alphagc,size[ipt],LineSolid,CapButt,JoinRound);
      XSetLineAttributes(x->dis,lyr->maskgc,size[ipt],LineSolid,CapButt,JoinRound);
      
      XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt]));
      XDrawLine(x->dis,lyr->rgb,lyr->rgbgc,xstart,ystart,xend,yend);
    
      XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  
      XDrawLine(x->dis,lyr->alpha,lyr->alphagc,xstart,ystart,xend,yend);
      
      XSetForeground(x->dis,lyr->maskgc,1);
      XDrawLine(x->dis,lyr->mask,lyr->maskgc,xstart,ystart,xend,yend);
    }
    else if(drawtype=='p') //dashed line
    {
      if(ipt%2==1) //only draw every second line-segment starting with first point-pair in the list
      {
        XSetLineAttributes(x->dis,lyr->rgbgc,size[ipt],LineSolid,CapButt,JoinRound);
        XSetLineAttributes(x->dis,lyr->alphagc,size[ipt],LineSolid,CapButt,JoinRound);
        XSetLineAttributes(x->dis,lyr->maskgc,size[ipt],LineSolid,CapButt,JoinRound);
        
	XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,red[ipt],green[ipt],blue[ipt]));
        XDrawLine(x->dis,lyr->rgb,lyr->rgbgc,xstart,ystart,xend,yend);
    
        XSetForeground(x->dis,lyr->alphagc,get_palette_rgb(x,CHWHITE,CHWHITE,alpha[ipt]));  
        XDrawLine(x->dis,lyr->alpha,lyr->alphagc,xstart,ystart,xend,yend);
      
        XSetForeground(x->dis,lyr->maskgc,1);
        XDrawLine(x->dis,lyr->mask,lyr->maskgc,xstart,ystart,xend,yend);
/*  
  //reset progressively for debug
  XSetClipMask(x->dis,lyr->rgbgc,lyr->mask);
  XSetClipMask(x->dis,lyr->alphagc,lyr->mask);
  XSetClipMask(x->dis,lyr->maskgc,lyr->mask);
*/      }
    }
  }

/*  
  XSetForeground(x->dis,lyr->rgbgc,get_palette_rgb(x,CHWHITE,0,CHWHITE));
  XFillRectangle(x->dis,lyr->rgb,lyr->rgbgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
    
  XSetForeground(x->dis,lyr->alphagc,get_palette_grey(x,WHITE));
  XFillRectangle(x->dis,lyr->alpha,lyr->alphagc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
  
  XSetForeground(x->dis,lyr->maskgc,1);
  XFillRectangle(x->dis,lyr->mask,lyr->maskgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
*/
}

void draw_raster(xsrv *x,xbox *box,xlyr *lyr,int nx,int ny,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha)
{
  //puts image into screen double buffer
  unsigned int width,height;
  unsigned int ix,iy,userpt,screenpt;
  unsigned int xoffset,yoffset,xtotal,ytotal,xsize,ysize;
  XImage *imrgb;
  XImage *imalpha;

  // ****************************************************** //
  // ** DRAW RASTER GRAPHICS FROM CLIENT TO SERVER LAYER ** //
  // ****************************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;
  
  printf("xserver: draw_raster [%d:%d,%d:%d]\n",box->xmin,box->xmax,box->ymin,box->ymax);
  
  width=box->xmax-box->xmin;
  height=box->ymax-box->ymin;
  
  if(nx!=width||ny!=height) 
  { 
    printf("xserver: error: nx=%d width=%d ny=%d height=%d\n",nx,width,ny,height); 
    return; 
  }

  imrgb=XCreateImage(x->dis,x->vis,x->bitdepth,ZPixmap,0,NULL,width,height,x->bquantum<<3,0);
  imalpha=XCreateImage(x->dis,x->vis,x->bitdepth,ZPixmap,0,NULL,width,height,x->bquantum<<3,0);
  if(!invalidptr(E,imrgb)&&
     !invalidptr(E,imalpha)) 
  {
    imrgb->data=NULL;
    imalpha->data=NULL;
    imrgb->data=imalloc(E,imrgb->bytes_per_line*height);
    imalpha->data=imalloc(E,imalpha->bytes_per_line*height);
    
    if(!invalidptr(E,imrgb->data)&&
       !invalidptr(E,imalpha->data))
    {
      for(ix=0;ix<width;ix++)
        for(iy=0;iy<height;iy++)
        {
          userpt=ix+(height-1-iy)*width; //flip to right-handed coordinates 
          //userpt=ix+iy*width; 
	  screenpt=ix+iy*width;
 
          //*((uint8_t *) image->data+screenpt)=(uint8_t) ...; //8 bit equivalent 
	  *((unsigned int *) imrgb->data+screenpt)=(unsigned int) get_raster_rgb(x,imrgb,red[userpt],green[userpt],blue[userpt]); 
          *((unsigned int *) imalpha->data+screenpt)=(unsigned int) get_raster_rgb(x,imalpha,CHWHITE,CHWHITE,alpha[userpt]); //alpha == blue
        }
   
      //take unclipped raster image from client memory onto layer buffer, not directly to screen
      XSetClipMask(x->dis,lyr->rgbgc,None);
      XSetClipMask(x->dis,lyr->alphagc,None);
      XPutImage(x->dis,lyr->rgb,lyr->rgbgc,imrgb,0,0,0,0,width,height); 
      XPutImage(x->dis,lyr->alpha,lyr->alphagc,imalpha,0,0,0,0,width,height); 
    }

    XDestroyImage(imrgb);
    XDestroyImage(imalpha);

    XSetForeground(x->dis,lyr->maskgc,1); 
    XFillRectangle(x->dis,lyr->mask,lyr->maskgc,0,0,width,height);
  }
}

void draw_clear(xsrv *x,xbox *box,xlyr *lyr)
{
  // ************************************* //
  // ** CLEAR THIS BOX OF PRIOR DRAWING ** //
  // ************************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;
  
  printf("xserver: draw_clear\n");

  XSetForeground(x->dis,lyr->rgbgc,get_palette_grey(x,WHITE));
  XFillRectangle(x->dis,lyr->rgb,lyr->rgbgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
    
  XSetForeground(x->dis,lyr->alphagc,get_palette_grey(x,BLACK));
  XFillRectangle(x->dis,lyr->alpha,lyr->alphagc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
  
  XSetForeground(x->dis,lyr->maskgc,0);
  XFillRectangle(x->dis,lyr->mask,lyr->maskgc,0,0,box->xmax-box->xmin,box->ymax-box->ymin);
}

void init_layer(xsrv *x,xbox *box,unsigned lyrhash,char type)
{
  xlyr **tmp;
  int ilyr;

  // ********************************************** //
  // ** INITIALISE PARAMETERS FOR A SERVER LAYER ** //
  // ********************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  if(box->lyrmem=='t')
  {
    printf("xserver: appending layer to list\n");

    if(box->nlayers>0)
    {
      tmp=box->layer; //save existing list

      box->layer=NULL;
      box->layer=(xlyr **)imalloc(E,(box->nlayers+1)*sizeof(xlyr *));
      if(!invalidptr(E,box->layer))
      {
        for(ilyr=0;ilyr<box->nlayers;ilyr++)
          box->layer[ilyr]=tmp[ilyr]; //copy existing to new
	
	box->layer[box->nlayers]=NULL;
	box->layer[box->nlayers]=(xlyr *)imalloc(E,sizeof(xlyr)); //make new layer
        if(!invalidptr(E,box->layer[box->nlayers]))
	{
          box->layer[box->nlayers]->hash=lyrhash; //name the layer
          box->layer[box->nlayers]->type=type;
	  box->layer[box->nlayers]->lyrmem='f';
	  box->layer[box->nlayers]->visible='f';
	  box->layer[box->nlayers]->vieworder=-1;
	  box->layer[box->nlayers]->viewlogic='\0';
          
	  init_canvas(x,box,box->layer[box->nlayers]);

          box->nlayers++;
	  tmp=ifree(E,tmp);                              //dealloc old list
	}
      }
      else
      {
        box->layer=tmp; //if imalloc fails, replace existing pointer
      }
    }
  }
  else
  {
    printf("xserver: initialising layer list\n");
   
    box->layer=NULL;
    box->layer=(xlyr **)imalloc(E,sizeof(xlyr *));
    if(!invalidptr(E,box->layer))
    {
      box->layer[0]=NULL;
      box->layer[0]=(xlyr *)imalloc(E,sizeof(xlyr));
      if(!invalidptr(E,box->layer[0]))
      {
        box->layer[0]->hash=lyrhash;
	box->layer[0]->type=type; 
	box->layer[0]->lyrmem='f'; //internal memory flag
	box->layer[0]->visible='f';
	box->layer[0]->vieworder=-1;
	box->layer[0]->viewlogic='\0';
	
	init_canvas(x,box,box->layer[0]);
        
	box->nlayers=1;
	box->lyrmem='t';  //external memory flag
      }
    }
  }
}

int reorder_layer(xsrv *x,xbox *box,unsigned lyrhash)
{ 
  int ilyr;
  int iold;
  int inew;
  int nvisible;

  // *********************************************************************** //
  // ** REMOVE A LAYER FROM VISIBILITY AND ARRANGE LAYER LIST ACCORDINGLY ** //
  // *********************************************************************** //

  if(!invalidptr(E,x)&&
     !invalidptr(E,box))
  {
    if(box->nlayers>0&&box->lyrmem=='t'&&!invalidptr(E,box->layer))
    { 
      //printf("before: reorder %u\n",lyrhash);
      //for(ilyr=0;ilyr<box->nlayers;ilyr++)
      //  printf("before: name: %u order: %d %c\n",box->layer[ilyr]->hash,box->layer[ilyr]->vieworder,box->layer[ilyr]->visible);

      //compute total visible including lyrhash 
      nvisible=0;
      for(ilyr=0;ilyr<box->nlayers;ilyr++)
        if(!invalidptr(E,box->layer[ilyr]))
          if(box->layer[ilyr]->visible=='t')
            nvisible++;

      //find carg->layer and set to invisible if currently visible
      for(ilyr=0;ilyr<box->nlayers;ilyr++)
        if(!invalidptr(E,box->layer[ilyr]))
          if(box->layer[ilyr]->hash==lyrhash)
            if(box->layer[ilyr]->visible=='t')
	    {
              box->layer[ilyr]->vieworder=-1;
	      box->layer[ilyr]->visible='f';
	    }
      
      //printf("during: reorder %u\n",lyrhash);
      //for(ilyr=0;ilyr<box->nlayers;ilyr++)
      //  printf("during: name: %u order: %d %c\n",box->layer[ilyr]->hash,box->layer[ilyr]->vieworder,box->layer[ilyr]->visible);

      //recompute sequence to eliminate jump
      inew=0;
      for(iold=0;iold<nvisible;iold++)
      {
        for(ilyr=0;ilyr<box->nlayers;ilyr++)
	  if(!invalidptr(E,box->layer[ilyr]))
            if(box->layer[ilyr]->vieworder==iold)
            {
	      box->layer[ilyr]->vieworder=inew;
	      inew++;
            }
      }
      
      //printf("after: reorder %u\n",lyrhash);
      //for(ilyr=0;ilyr<box->nlayers;ilyr++)
      //  printf("after: name: %u order: %d %c\n",box->layer[ilyr]->hash,box->layer[ilyr]->vieworder,box->layer[ilyr]->visible);
      //printf("after: inew=%d\n",inew);

      return inew; //return the next vieworder
    }
  }

  return 0;
}

void close_layer(xsrv *x,xbox *box,xlyr *lyr,unsigned name)
{
  xlyr **tmp;
  xlyr *temp;
  int ilyr;
  int sniplayer;
  unsigned lyrhash;

  // ********************************************* //
  // ** RELEASE RESOURCES FOR THIS SERVER LAYER ** //
  // ********************************************* //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  if(invalidptr(E,lyr)) return;

  if(box->lyrmem=='t')
  {
    printf("xserver: deleting layer from list\n");

    if(box->nlayers>0&&!invalidptr(E,box->layer))
    {
      //find layer to snip out of list - either by variable pointer or by name
      sniplayer=-1;
      lyrhash=0;
      if(name!=0) lyrhash=name;
      if(!invalidptr(E,lyr)) lyrhash=lyr->hash;

//printf("box=%p box->nlayers=%d box->layer=%p box->layer[0]=%p\n",box,box->nlayers,box->layer,box->layer[0]);

      //identify its index
      for(ilyr=0;ilyr<box->nlayers;ilyr++)
        if(!invalidptr(E,box->layer[ilyr]))
          if(box->layer[ilyr]->hash==lyrhash)
	    sniplayer=ilyr;
     
      //dealloc memory for this layer
      if(sniplayer>=0)
        if(!invalidptr(E,box->layer[sniplayer]))
	{
          tmp=box->layer; //save existing
	  
	  if(!invalidptr(E,box->layer[sniplayer]))
	  {
	    if(box->layer[sniplayer]->lyrmem=='t')
	      close_canvas(x,box,box->layer[sniplayer]);

            if(!invalidptr(E,box->layer[sniplayer]))
	      if(box->layer[sniplayer]->lyrmem=='f')
	        box->layer[sniplayer]=ifree(E,box->layer[sniplayer]); //free underlying object 
	  }

	  if(box->nlayers>0)
	  {
            box->layer=NULL;
            box->layer=(xlyr **)imalloc(E,(box->nlayers-1)*sizeof(xlyr *));
            if(!invalidptr(E,box->layer))
            {  
              for(ilyr=0;ilyr<sniplayer;ilyr++)
	        box->layer[ilyr]=tmp[ilyr];        //copy pre
	      for(ilyr=sniplayer+1;ilyr<box->nlayers;ilyr++)
	        box->layer[ilyr-1]=tmp[ilyr];      //copy post

	      tmp=ifree(E,tmp);

              box->nlayers--;
            }
	  }
          else
          {
            box->layer=tmp;
	  }
        }
    }

    if(box->nlayers<=0)
      box->lyrmem='f';
  }
}

void init_canvas(xsrv *x,xbox *box,xlyr *lyr)
{
  unsigned int width,height;

  // ****************************************** //
  // ** INITIALISE LAYER RGB, ALPHA AND MASK ** //
  // ****************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  if(!invalidptr(E,lyr))
    if(lyr->lyrmem=='f')
    {
      printf("xserver: init canvas\n");

      width=box->xmax-box->xmin;
      height=box->ymax-box->ymin;
    
      //create buffers and masks
      lyr->rgb=XCreatePixmap(x->dis,x->win,width,height,x->depth);
      lyr->alpha=XCreatePixmap(x->dis,x->win,width,height,x->depth); //use 8-bits of the 24 
      lyr->mask=XCreatePixmap(x->dis,x->win,width,height,1); //1-bit bitmap
     
      lyr->rgbgc=XCreateGC(x->dis,lyr->rgb,0,NULL);
      lyr->alphagc=XCreateGC(x->dis,lyr->alpha,0,NULL);
      lyr->maskgc=XCreateGC(x->dis,lyr->mask,0,NULL);

      //set rgb buffer to white
      XSetBackground(x->dis,lyr->rgbgc,get_palette_grey(x,WHITE)); 
      XFillRectangle(x->dis,lyr->rgb,lyr->rgbgc,0,0,width,height); 
 
      //set alpha buffer to transparent
      XSetBackground(x->dis,lyr->alphagc,get_palette_grey(x,BLACK)); 
      XFillRectangle(x->dis,lyr->alpha,lyr->alphagc,0,0,width,height); 

      //clear binary clipping mask
      XSetBackground(x->dis,lyr->maskgc,0); 
      XFillRectangle(x->dis,lyr->mask,lyr->maskgc,0,0,width,height); 
    
      lyr->lyrmem='t';
    }
}

void close_canvas(xsrv *x,xbox *box,xlyr *lyr)
{
  // ************************************** //
  // ** RELEASE RESOURCES FOR THIS LAYER ** //
  // ************************************** //

  if(invalidptr(E,x)) return;

  if(!invalidptr(S,lyr))
    if(lyr->lyrmem=='t')
    {
      printf("xserver: closing canvas\n");

      XFreePixmap(x->dis,lyr->rgb);
      XFreePixmap(x->dis,lyr->alpha);
      XFreePixmap(x->dis,lyr->mask);
      XFreeGC(x->dis,lyr->rgbgc);
      XFreeGC(x->dis,lyr->alphagc);
      XFreeGC(x->dis,lyr->maskgc);

      lyr->lyrmem='f';
    }
}

void init_text(xsrv *x,xbox *box)
{
  int ic;
  xtxt *write;
  char fline[MAXLEN];

  // *********************************** //
  // ** ALLOCATE SPACE FOR A TEXT BOX ** //
  // *********************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;
  
  if(box->wrtmem=='f')
  {
    box->write=NULL;
    box->write=(xtxt **)imalloc(E,sizeof(xtxt *));
    if(!invalidptr(E,box->write))
    {
      box->write[0]=NULL;
      box->write[0]=(xtxt *)imalloc(E,sizeof(xtxt));
   
      if(!invalidptr(E,box->write[0]))
      {
        write=box->write[0];

        //printf("box->xfontsize=%d\n",box->xfontsize);
        //printf("box->yfontsize=%d\n",box->yfontsize);
        //printf("box->xmin=%d\n",box->xmin);
        //printf("box->xmax=%d\n",box->xmax);
        //printf("write->linelen=%d\n",-2+(box->xmax-box->xmin)/box->xfontsize);
        //printf("box->ymin=%d\n",box->ymin);
        //printf("box->ymax=%d\n",box->ymax);
        //printf("write->nlines=%d\n",(box->ymax-box->ymin)/box->yfontsize);

        //text attributes
        write->xcursor=box->xfontsize/2; //set (relative) starting cursor position
        write->ycursor=box->yfontsize/2;
        write->linelen=-2+(box->xmax-box->xmin)/box->xfontsize; //integer division
        write->nlines=(box->ymax-box->ymin)/box->yfontsize;
        write->nchars=0;
  
        //allocate and initialise memory for command string
        write->text=NULL;
        write->text=(char *)imalloc(E,write->linelen*write->nlines*sizeof(char));
        if(!invalidptr(E,write->text))
          for(ic=0;ic<write->linelen*write->nlines;ic++)
            write->text[ic]=STRINGEND;
     
        box->nwrites=1;
        box->wrtmem='t';

        //printf("text[%d]=%s\n",write->linelen*write->nlines,write->text);
      }
    }
  }
}

void close_text(xsrv *x,xbox *box)
{
  // ************************************** //
  // ** RELEASE RESOURCES FOR A TEXT BOX ** //
  // ************************************** //

  if(invalidptr(E,x)) return;
  if(invalidptr(E,box)) return;

  if(box->wrtmem=='t')
  {
    if(!invalidptr(E,box->write))
    {
      if(!invalidptr(E,box->write[0]))
      {
        box->write[0]->text=ifree(E,box->write[0]->text);
        box->write[0]=ifree(E,box->write[0]);
      }
      box->write=ifree(E,box->write);
      box->write=NULL; //ensure that we don't come here again
    }
    box->wrtmem='f';
    box->nwrites=0;
  }
}
#endif 

void request_event_keystroke(char *inst,char ch,int panel,int *running)
{
  xreq *carg;

  // ******************************************************* //
  // ** HANDLE REQUEST FROM CLIENT OR GUI FOR A KEY PRESS ** //
  // ******************************************************* //

  carg=NULL;
  carg=(xreq *)imalloc(E,sizeof(xreq));
  if(invalidptr(E,carg)) return;

  carg->wintag=str_hash(inst);
  carg->keystroke=ch;
  carg->cmd=str_hash("keystroke");
  carg->panel=panel;
  carg->running=running;

  xserver_event_send((void *)carg);
}

void request_event_mouse(char *inst,int mx,int my,int mb)
{
  xreq *carg;

  // ******************************************************* //
  // ** HANDLE REQUEST FROM CLIENT OR GUI FOR MOUSE CLICK ** //
  // ******************************************************* //

  carg=NULL;
  carg=(xreq *)imalloc(E,sizeof(xreq));
  if(invalidptr(E,carg)) return;

  carg->wintag=str_hash(inst);
  carg->xmouse=mx;
  carg->ymouse=my;
  carg->bmouse=mb;

  carg->cmd=str_hash("mouse");

  xserver_event_send((void *)carg);
}

void request_event_write(char *inst,int nstring,char *string)
{
  int ichar;
  xreq *carg;
  char *clean;

  // ************************************************************************ //
  // ** HANDLE REQUEST FROM CLIENT OR GUI FOR TEXT TO BE WRITTEN TO SCREEN ** //
  // ************************************************************************ //

  //ensure that client arguments are allocated on the heap for long-term accessibility
  carg=NULL;
  carg=(xreq *)imalloc(E,sizeof(xreq));
  if(invalidptr(E,carg)) return;

  carg->wintag=str_hash(inst);
  carg->cmd=str_hash("write"); 
  carg->ntext=nstring;
  
  carg->text=NULL;
  carg->text=(char *)imalloc(E,(nstring+1)*sizeof(char)); //allocate text memory in carg, ifree'd in handle_cmd_write
  if(invalidptr(E,carg)) return;

  memset(carg->text,0,sizeof(char)*(nstring+1));

  for(ichar=0;ichar<nstring;ichar++)
    carg->text[ichar]=string[ichar];
  carg->text[nstring]=STRINGEND;

  xserver_event_send((void *)carg);
}

void request_event_screen(char *inst,unsigned command,int panel)
{
  xreq *carg;

  // *********************************************************************** //
  // ** HANDLE REQUEST FROM CLIENT OR GUI FOR SCREEN UPDATE, WIPE OR COPY ** //
  // *********************************************************************** //
 
  //ensure that client arguments are allocated on the heap for long-term accessibility
  carg=NULL;
  carg=(xreq *)imalloc(E,sizeof(xreq));
  if(invalidptr(E,carg)) return;

  carg->wintag=str_hash(inst);
  carg->cmd=str_hash("null"); 
  if(command==str_hash("update")) 
  {
    carg->cmd=str_hash("screenupdate");
    printf("xserver: request_event_screen update\n");
  }
  else if(command==str_hash("clean"))
  {
    carg->cmd=str_hash("screenclean");
    printf("xserver: request_event_screen clean\n");
  }
  else if(command==str_hash("grab")) 
  {
    carg->cmd=str_hash("screengrab");
    printf("xserver: request_event_screen grab\n");
  }
  carg->panel=panel;
  
  xserver_event_send((void *)carg);
}

void request_event_vector(char *inst,unsigned lyrhash,int panel,unsigned drawtype,char fill,int npts,int *xpt,int *ypt,int *size,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha)
{
  xreq *carg;

  // ************************************* //
  // ** CLIENT REQUESTS VECTOR GRAPHICS ** //
  // ************************************* //

  if(invalidptr(E,xpt)) return;
  if(invalidptr(E,ypt)) return;
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;
  
  printf("xserver: request_event_vector\n");
 
  carg=NULL;
  carg=(xreq *)imalloc(E,sizeof(xreq));
  if(invalidptr(E,carg)) return;

  carg->wintag=str_hash(inst);
  
  //populate draw structure
  carg->cmd=drawtype;
  carg->fill=fill;
  carg->panel=panel;
  carg->layer=lyrhash;
  carg->npts=npts; //how to seg fault a program... take user data on trust
  
  //leave user memory intact, and simply copy pointer to their data
  carg->xpt=xpt;
  carg->ypt=ypt;
  carg->size=size;
  carg->red=red;
  carg->green=green;
  carg->blue=blue;
  carg->alpha=alpha;

  xserver_event_send((void *)carg);
}

void request_event_raster(char *inst,unsigned lyrhash,int panel,int nx,int ny,uint8_t *red,uint8_t *green,uint8_t *blue,uint8_t *alpha)
{
  xreq *carg;

  // **************************************************************** //
  // ** CLIENT REQUESTS COPY OF RASTER IMAGE FROM CLIENT TO SERVER ** //
  // **************************************************************** //
 
  if(invalidptr(E,red)) return;
  if(invalidptr(E,green)) return;
  if(invalidptr(E,blue)) return;
  if(invalidptr(E,alpha)) return;
  
  printf("xserver: request_event_raster\n");

  carg=NULL;
  carg=(xreq *)imalloc(E,sizeof(xreq));
  if(invalidptr(E,carg)) return;

  carg->wintag=str_hash(inst);
  carg->cmd=str_hash("drawraster");
  carg->panel=panel;
  carg->layer=lyrhash;
  carg->type='r';
  carg->nx=nx;
  carg->ny=ny;
  carg->red=red;
  carg->green=green;
  carg->blue=blue;
  carg->alpha=alpha;

  xserver_event_send((void *)carg);
}

void request_event_layer(char *inst,unsigned lyrhash,int panel,unsigned command)
{
  xreq *carg;
 
  // ************************************************************** //
  // ** RESPOND TO CLIENT REQUEST FOR LAYER ACCUMULATION OR COPY ** //
  // ************************************************************** //
 
  carg=NULL;
  carg=(xreq *)imalloc(E,sizeof(xreq));
  if(invalidptr(E,carg)) return;

  printf("xserver: request_event_layer: panel=%d lyrhash=%u command=%d\n",panel,lyrhash,command);

  carg->wintag=str_hash(inst);
  carg->panel=panel;
  carg->layer=lyrhash;

  carg->cmd=str_hash("null");
  if(command==str_hash("expose"))        carg->cmd=str_hash("layerexpose");   //expose layer on dbuf
  else if(command==str_hash("paint"))    carg->cmd=str_hash("layerexpose");   //expose layer on dbuf
  else if(command==str_hash("in"))       carg->cmd=str_hash("layerexpose");   //expose layer on dbuf
  else if(command==str_hash("out"))      carg->cmd=str_hash("layerexpose");   //expose layer on dbuf
  else if(command==str_hash("atop"))     carg->cmd=str_hash("layerexpose");   //expose layer on dbuf
  else if(command==str_hash("xor"))      carg->cmd=str_hash("layerexpose");   //expose layer on dbuf
  else if(command==str_hash("conceal"))  carg->cmd=str_hash("layerconceal");  //conceal layer on dbuf
  else if(command==str_hash("init"))     carg->cmd=str_hash("layerinit");     //memory for layer
  else if(command==str_hash("wipe"))     carg->cmd=str_hash("layerwipe");     //whitewash layer
  else if(command==str_hash("close"))    carg->cmd=str_hash("layerclose");    //close layer memory
  else if(command==str_hash("grab"))     carg->cmd=str_hash("layergrab");     //pass layer to client
  else if(command==str_hash("transfer")) carg->cmd=str_hash("layertransfer"); //transfer dbuf to layer

  //pass render options
  if(command==str_hash("expose"))        carg->logic='e';
  else if(command==str_hash("paint"))    carg->logic='p';
  else if(command==str_hash("in"))       carg->logic='i';
  else if(command==str_hash("out"))      carg->logic='o';
  else if(command==str_hash("atop"))     carg->logic='t';
  else if(command==str_hash("xor"))      carg->logic='x';
 
  xserver_event_send((void *)carg);
}

void *xserver_xsrv_destroy(void *arglist)
{
  xsrv *server;
  void *argptr;
 
  // ******************************************** //
  // ** RELEASE MEMORY FOR XSRV DATA STRUCTURE ** //
  // ******************************************** //

  if(dynamic_getarg(arglist,"object",&argptr)=='f') return NULL;
  if(!invalidptr(E,argptr)) return NULL;
  server=(xsrv *) argptr;

  printf("xserver: closing\n");

  server=ifree(E,server);

  return NULL;  
}
